Here's the task description

1. Task
In this lab, you will implement a normal operation of Paxos, but without a leader, where two proposers are trying to get their proposals to succeed. This is similar to the example from slide 46 from the Paxos slides. We will refer to all servers as peers.

Each peer starts by knowing a list representing the set of peers that are part of this Paxos configuration. Peer ids will be assigned based on the line in the file, starting at 1. To make it easier, you will specify in the configuration file, what role a peer has: proposer, acceptor, learner.

First you will implement normal Paxos operation where the process with the lowest id will try to propose a value and nothing goes wrong. Follow the description of the variables from slide 45. The second case you will implement is when both peer1 and peer2 submit a proposal.

At the end, all peers should print the chosen value. You can assume that the number of peers is 5. You should test your code with 5 nodes and provide the testcases described below.

You can use C/C++, Java, or Go. Communication can be implemented with TCP. Communi- cation should be reliable. All messages must be printed verbatim—they should all be valid JSON strings.
1. PART 1: Normal operation of Paxos with 1 proposer
After all peers have started, the peer with the lowest id will initiate a proposal and perform the Paxos normal operation as described in slide 45. Each peer will print on the screen what message they sent and what message they received. Note that from the configuration file, a peer will know if it is an acceptor or not. This will help with minimizing the number of messages that are sent. The proposer will communicate only with its acceptors as defined in the configuration file. For example, you can configure that peer2 and peer3 are acceptors for proposer peer1. You don’t need to worry about the learners learning the value.

Sent and received messages should be of the following format, where <TEXT> should be replaced with your program-specific values. Message type can be one of: “prepare”, “prepare ack”, “accept”, “accept ack”. Action should either be “sent” or “received”. Message value should be “X” or “Y”.

{"peer_id":<SENDER_ID>, "action": "<ACTION>",
"message_type":"<TYPE>",
"message_value":"<VALUE>",

 "proposal_num":<PROPOSAL_NUMBER>}

Example:

{"peer_id": 1, "action": "sent",
"message_type":"prepare_ack",
"message_value":"X",
"proposal_num":5}

When a value is chosen by a peer, it should print the following:

{"peer_id":<SENDER_ID>, "action": "chose",
"message_type":"chose",
"message_value":"<VALUE>",
"proposal_num":<PROPOSAL_NUMBER>}

Example:

{"peer_id":3, "action": "chose",
"message_type":"chose",
"message_value":"Y",
"proposal_num":7}

TESTCASE 1: All peers start, peer with the lowest id initiates a proposal with a value X given through the command line. All peers print the messages they receive and send. (Peers that are not involved in the protocol print nothing). All peers that participate in the protocol should agree on value X.
1. PART 2: Two competing proposals with different values
In this part, there will be two proposers that will try to push their own value independently of each other. In this case, you will need another configuration file where you specify who the acceptors are for proposer 1 (the peer with the lowest id, peer1) and for proposer 2 (the peer with the highest id, peer5), like the example in the slides, peer2 and peer3 will work with proposer 1 (peer1) and peer3 and peer4 will work with proposer 2 (peer5).

The key here is that peer5 should initiate the proposal after peer3 sends the accept to the proposal from peer1—as in the example in slide 46. All peers should end up with value X, even if peer5 was trying to push value Y.

To control when peer5 starts its proposal, you can use a timeout. From testcase 1 you will have some idea how long it takes for proposal 1 to complete.

TESTCASE 2: Peer1 starts with value X, after peer3 answers with accept to peer1’s proposal, peer5 starts a proposal with value Y. All peers should agree on value X. The same printed messages should be used as in part 1.

Implementation
You need to implement this algorithm in C/C++, Java, or Go, and your implementation must allow the user to configure the execution of the process. You will again be using Docker to package your program. Additionally, you must use Docker Compose as a container orchestrator. Instructions on how to use Docker Compose are provided in the Docker Tutorial. You will be provided with a Docker Compose file for each of the two testcases. You must be able to run each of the Compose configurations and see the expected outputs printed to the screen. The expected interface for your containers is provided below. If you adhere to this interface, then Docker Compose will work seamlessly, without any changes.

You will also receive a hostsfile.txt specifying the hosts and roles of the five peers for each testcase. You may test on your own hostsfiles, but to receive full credit, your code must be compatible with the one provided. The hostsfile has the following format. Each line starts with the hostname of the peer followed by a colon. To the right of the colon is a comma-separated list of the roles that peer fills. If the roles are specific to a peer, then the role is appended with a numeric identifier. For example, the acceptors of proposer1 have the role acceptor1. An example hostsfile

may look like the following

  peer1:proposer1
  peer2:acceptor1,acceptor2
  peer3:acceptor1,acceptor2
  peer4:acceptor1,learner1
  peer5:proposer2

Note: you must implement all CLI arguments exactly as written below to receive full credit.

parameter
 -h hostsfile
      The hostsfile is the path to a file that contains
      the list of hostnames that the processes are
      running on. It assumes that each host is running
      only one instance of the process.
      ...

      All the processes will listen on the same port.
      The line number indicates the identifier of the process
      which starts at 1.

   -v value
      This is the value used if the peer is a proposer. It is a character.

   -t delay
      This is the time in seconds proposer 2 will wait before starting its proposal with its value v. This will be needed for the second testcase scenario.

2. Here's my code
package main  
  
import (  
    "bufio"  
    "encoding/gob"    "flag"    "fmt"    "net"    _ "net/http/pprof"  
    "os"    "sort"    "strconv"    "strings"    "sync"    "time")  
  
// Global Variables  
// https://pkg.go.dev/time#Duration  
var (  
    DEFAULT_PORT int           = 3000  
    DELAY        time.Duration = 0 * time.Second  
    //DNS Request Failed and retry to retrieve hostname  
    DNS_REQUEST_DELAY      time.Duration = 1500 * time.Millisecond  
    ROLE_ORDER                           = 1  
    START_TIME                           = time.Time{}  
    PROPOSER_SEND_INTERVAL               = 2500 * time.Millisecond  
    ACCEPTOR_SEND_INTERVAL               = 2000 * time.Millisecond  
)  
  
// Logger  
// type VerboseLevel int  
const (  
    VERBOSE_SUBMISSION = iota  
    VERBOSE_ERROR  
    VERBOSE_WARNING    VERBOSE_INFO    VERBOSE_DEBUG)  
  
var currentVerboseLevel = VERBOSE_DEBUG  
var submissionSurpress = true  
  
var logMessageMutex sync.Mutex  
  
func log_message(verboseLevel int, format string, args ...interface{}) {  
    logMessageMutex.Lock()  
    defer logMessageMutex.Unlock()  
  
    if currentVerboseLevel == VERBOSE_DEBUG {  
       //https://jeonghwan-kim.github.io/dev/2019/01/14/go-time.html weird time specifier  
       now := time.Since(START_TIME)  
       seconds := int(now.Seconds()) % 60  
       milliseconds := int(now.Milliseconds()) % 1000  
       formattedTime := fmt.Sprintf("%02d.%04d ", seconds, milliseconds)  
  
       fmt.Fprintf(os.Stderr, formattedTime)  
    }  
    if verboseLevel <= currentVerboseLevel {  
       // stderr  
       fmt.Fprintf(os.Stderr, format, args...)  
    }  
}  
  
// Message (Payload) Structtype Message struct {  
    SrcID  int //SrcID for the source  
    DestID int //DestID for the destination  
    /*       1.Broadcast Prepare(n) to all servers          MessageType : PREPARE          ProposalNumber : RoundNumber.ServerID  
       2.Respond to Prepare(n)          MessageType : PREPARE_ACK  
          ProposalNumber: If Exist (RoundNumber.ServerID) If NOT NIL or equivalent          MessageValue : If Exist (Char) IF NOT NIL or equivalent  
       3.Broadcast Accept(n, value) to all servers          MessageType : PREPARE_ACK  
          ProposalNumber : RoundNumber.ServerID (Accepted One)          MessageValue : A Character (Accepted One)  
       4.Respond to Accept(n, value)       MessageType : ACCEPT_ACK  
  
       ProposalNumber : RoundNumber.ServerID (MinProposal)    */    MessageType    MessageType //Enum  
    ProposalNumber string      // Proposal Num -> String : On the network uses string but internally, uses Proposal Number in a data structure    MessageValue   byte        //A single char value specified in the instruction  
}                    // Message Structtype MessageType int // Message Type TYPEconst (  
    PREPARE MessageType = iota // 0  
    PREPARE_ACK  
    ACCEPT    ACCEPT_ACK) // Message Type ACTUAL ENUMfunc (messageType MessageType) String() string {  
    switch messageType {  
    case PREPARE:  
       return "prepare"  
    case PREPARE_ACK:  
       return "prepare_ack"  
    case ACCEPT:  
       return "accept"  
    case ACCEPT_ACK:  
       return "accept_ack"  
    default:  
       return "unknown"  
    }  
}  
  
/*  
Proposal Management*/  
type Proposal struct {  
    ProposalNumber ProposalNumber  
    Value          byte  
} // Proposal Structtype ProposalNumber struct {  
    //Proposal Number = RoundNumber + ServerID  
    //Actual Value = RoundNumber.ServerID like 1.1, 5.5  
    //Lamport clock solution - ProcessID    RoundNumber int  
    ServerID    int  
}  
  
/*  
Interfaces : https://go.dev/tour/methods/9  
Interfaces : https://gobyexample.com/interfaces  
*/  
func (pn ProposalNumber) GreaterThan(other ProposalNumber) bool {  
    if pn.RoundNumber > other.RoundNumber {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number\n")  
       return true  
    } else if pn.RoundNumber == other.RoundNumber && pn.ServerID > other.ServerID {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number = Server >\n")  
       return true  
    }  
    return false  
}  
func (pn ProposalNumber) LessThan(other ProposalNumber) bool {  
    if pn.RoundNumber < other.RoundNumber {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number\n")  
       return true  
    } else if pn.RoundNumber == other.RoundNumber && pn.ServerID < other.ServerID {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number = Server >\n")  
       return true  
    }  
    return false  
}  
func (pn ProposalNumber) IsEmpty() bool {  
    return pn.RoundNumber == 0 && pn.ServerID == 0  
}  
func (pn ProposalNumber) Equal(other ProposalNumber) bool {  
    return pn.RoundNumber == other.RoundNumber && pn.ServerID == other.ServerID  
}  
func (pn ProposalNumber) GreaterThanOrEqual(other ProposalNumber) bool {  
    return pn.GreaterThan(other) || pn.Equal(other)  
}  
  
func (pn ProposalNumber) String() string {  
    return fmt.Sprintf("%d.%d", pn.RoundNumber, pn.ServerID)  
} // to string  
  
func ParseProposalNumber(s string) (ProposalNumber, error) {  
    parts := strings.Split(s, ".")  
    if len(parts) != 2 {  
       return ProposalNumber{}, fmt.Errorf("invalid format: %s", s)  
    }  
  
    roundNumber, err := strconv.Atoi(parts[0])  
    if err != nil {  
       return ProposalNumber{}, fmt.Errorf("invalid round number: %s", parts[0])  
    }  
  
    serverID, err := strconv.Atoi(parts[1])  
    if err != nil {  
       return ProposalNumber{}, fmt.Errorf("invalid server ID: %s", parts[1])  
    }  
  
    return ProposalNumber{  
       RoundNumber: roundNumber,  
       ServerID:    serverID,  
    }, nil  
} // to struct  
  
/*  
    Peer Management*/  
  
// Peer Structtype Peer struct {  
    PeerID   int    // PeerID - row number    IP       string // IP address    Port     int    // Port Number    Hostname string // Hostname  
    IsSelf   bool   // is Self?  
    //Lab4    //IsProposer bool //Proposer Flag    //IsAcceptor bool //Acceptor Flag    //IsLearner  bool //Learner Flag    //To pass Testcase2, Made a Map    //int = Round Number    Roles map[int]MessageStatus //Parses Hostsfile entities ends with integer. [INT] = Role  
  
    //PAXOS    Mutex            sync.Mutex     //  
    minProposal      ProposalNumber //minProposal specified in the algorithm  
    acceptedProposal ProposalNumber //acceptedProposal specified in the algorithm  
    acceptedValue    byte           //acceptedValue specified in the instruction. Unlike C GO uses byte to represent a single char. (ASCII)  
}  
  
func (peer *Peer) GetSortedRoles() []MessageStatus {  
  
    // 1. Roles to Slice  
    roleKeys := make([]int, 0, len(peer.Roles))  
    for key := range peer.Roles {  
       roleKeys = append(roleKeys, key)  
    }  
  
    // 2. Sorts  
    sort.Ints(roleKeys)  
  
    // 3. Adds Sorted Peer into the list  
    sortedRoles := make([]MessageStatus, 0, len(peer.Roles))  
    for _, key := range roleKeys {  
       sortedRoles = append(sortedRoles, peer.Roles[key])  
    }  
  
    return sortedRoles  
}  
  
// Message Structtype MessageStatus struct {  
    RoleType        RoleType //Role Type [ACCEPTOR,PROPOSER,LEARNER]  
    PrepareSent     bool     //PREPARE message  
    PrepareReceived bool     //PREPARE_ACK message  
    AcceptSent      bool     //ACCEPT message  
    AcceptReceived  bool     //ACCEPT_ACK message  
}  
  
// Role Struct  
type RoleType int  
  
const (  
    UNKNOWN RoleType = iota  
    PROPOSER  
    ACCEPTOR    LEARNER)  
  
type PeerMap struct {  
    Peers map[int]*Peer // PeerID : Peer Struct    Mutex sync.Mutex    // MUTEX to prevent concurrency issue  
}  
  
// NEW  
func NewPeerMap() *PeerMap {  
    //Creating a peer map  
    return &PeerMap{  
       Peers: make(map[int]*Peer),  
    }  
}  
  
// ADD  
func (peermap *PeerMap) AddPeer(peer *Peer) {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    //Peermap : Individual  
    peermap.Peers[peer.PeerID] = peer  
}  
  
// UPDATE  
func (peermap *PeerMap) UpdatePeer(peer *Peer) {  
    //Separted from Add case I need to add other logic in it  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    //Peermap : Individual  
    peermap.Peers[peer.PeerID] = peer  
}  
  
// DELETE  
func (peermap *PeerMap) DeletePeer(peerID int) {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    delete(peermap.Peers, peerID) // Peer Delete  
}  
  
// GET  
func (peermap *PeerMap) GetPeer(peerID int) (*Peer, bool) {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    peer, exists := peermap.Peers[peerID]  
    return peer, exists  
}  
  
// Find my self  
func GetPeerSelf(peerMap *PeerMap) (*Peer, error) {  
    peerMap.Mutex.Lock()  
    defer peerMap.Mutex.Unlock()  
  
    //Ittr each object in the map and return peer(pointer)  
    for _, peer := range peerMap.Peers {  
       if peer.IsSelf {  
          return peer, nil  
       }  
    }  
    return nil, fmt.Errorf("Where am I?\n")  
}  
  
// Map -> Sorted List  
func (peermap *PeerMap) GetAllPeersSorted() []*Peer {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
  
    // 1. PeerID to Slice  
    peerIDs := make([]int, 0, len(peermap.Peers))  
    for peerID := range peermap.Peers {  
       peerIDs = append(peerIDs, peerID)  
    }  
  
    // 2. Sorts  
    // https://pkg.go.dev/sort#Ints    sort.Ints(peerIDs)  
  
    // 3. Adds Sorted Peer into the list  
    sortedPeers := make([]*Peer, 0, len(peermap.Peers))  
    for _, id := range peerIDs {  
       sortedPeers = append(sortedPeers, peermap.Peers[id])  
    }  
  
    return sortedPeers  
}  
  
/*  
ProposerState Tracker  
    proposerStates[AcceptorID] = individual transaction  
Proposer creates this map to tracking PREPARE_ACK, ACCEPT_ACK value.1. When Proposer send message -> Create Entity in the map.  
2. When Proposer receive message -> Record  
3. When Proposer is COMMITTED with a value -> Reset  
*/  
var proposerProposal Proposal = Proposal{  
    ProposalNumber: ProposalNumber{  
       RoundNumber: 1,  
       ServerID:    1,  
    },  
    Value: byte(0),  
}  
  
type ProposerState struct {  
    Mutex sync.Mutex  
    //1.ProposalNumber and Value used during the process (init)    ProposalNumber ProposalNumber  
    Value          byte  
  
    //2.Prepare() Return(acceptedProposal, acceptedValue) Tracking  
    PrepareResponses *Proposal  
  
    //3.Accept() Return(minProposal) Tracking  
    AcceptResponses *Proposal  
}  
  
var proposerStates = make(map[int]*ProposerState)  
var proposerStatesMutex sync.Mutex  
  
func getProposerState(destID int) *ProposerState {  
    proposerStatesMutex.Lock()  
    defer proposerStatesMutex.Unlock()  
    return proposerStates[destID]  
} // In case Additional verification  
func storeProposerState(destID int, state *ProposerState) {  
    proposerStatesMutex.Lock()  
    defer proposerStatesMutex.Unlock()  
    log_message(VERBOSE_DEBUG, "storeProposerState() storing %d's proposer state.\n", destID)  
    proposerStates[destID] = state  
} //Init  
  
// PREPARE_ACK  
func CountPrepareResponses(proposerStates map[int]*ProposerState) int {  
    //1. Total Count is 0 = NON  
    totalCount := 0  
    //2. Count PrepareResponses  
    for _, state := range proposerStates {  
       if state.PrepareResponses != nil {  
          totalCount++  
       }  
    }  
    return totalCount  
}  
  
// ACCEPT_ACK  
func CountAcceptResponses(proposerStates map[int]*ProposerState) int {  
    //1. Total Count is 0 = NON  
    totalCount := 0  
    //2. Count AcceptResponses  
    for _, state := range proposerStates {  
       if state.AcceptResponses != nil {  
          totalCount++  
       }  
    }  
    return totalCount  
}  
  
/*  
    GENERAL UTILS*/  
// File -> PeerList  
func loadHosts(filename string) (*PeerMap, error) {  
    log_message(VERBOSE_DEBUG, "1. [CONFIG] READING A HOSTFILE\n")  
  
    //1. Open file  
    file, err := os.Open(filename)  
    if err != nil {  
       return nil, fmt.Errorf("no file detected: %v", err)  
    }  
    defer file.Close() //Automatically Close the file  
  
    peerMap := NewPeerMap()           //New Peer Map!  
    scanner := bufio.NewScanner(file) //Scanner  
    rowNumber := 1  
  
    currentHostname, err := getSelfHostname()  
    if err != nil {  
       return nil, fmt.Errorf("[CONFIG] could not get current hostname: %v", err)  
    }  
  
    for scanner.Scan() { //Everyline  
       line := strings.TrimSpace(scanner.Text())  
  
       if line == "" {  
          //Empty Line Skip  
          continue  
       }  
  
       //Left(Hostname) : Right(Roles)  
       parts := strings.Split(line, ":")  
       if len(parts) != 2 {  
          //If there's more than 2 or less than 2 strings = Error  
          log_message(VERBOSE_ERROR, "[Config] INCORRECT LINE: %s", line)  
          return nil, fmt.Errorf("[Config] INCORRECT LINE: %s", line)  
       }  
  
       //String:Left(0) = Hostname  
       hostname := strings.TrimSpace(parts[0])  
       //String:Right(1) = Role"S"  
       roles := strings.Split(strings.TrimSpace(parts[1]), ",")  
  
       //1. Map Creation  
       rolesMap := make(map[int]MessageStatus)  
       //2. Role Parsing (i,entity)  
       for _, role := range roles {  
          role = strings.TrimSpace(role) //White Space Separate  
          if role == "" {  
             continue  
          }  
  
          // Roletype, Identifier(index)  
          var roleType RoleType  
          var identifier int  
  
          //String Process  
          //3 : PROPOSER          //https://pkg.go.dev/strings#HasPrefix          if strings.HasPrefix(role, "proposer") {  
             roleType = PROPOSER  
             idStr := strings.TrimPrefix(role, "proposer") //String:integer  
             if idStr == "" {  
                return nil, fmt.Errorf("[Config] [proposer] Invalid identifier: %s", role)  
             } else {  
                //String -> Int  
                //https://pkg.go.dev/strconv                identifier, err = strconv.Atoi(idStr)  
                if err != nil {  
                   return nil, fmt.Errorf("[Config] [proposer] Invalid role identifier: %s", role)  
                }  
             }  
          } else if strings.HasPrefix(role, "acceptor") {  
             //3 : ACCEPTOR  
             roleType = ACCEPTOR  
             idStr := strings.TrimPrefix(role, "acceptor")  
             if idStr == "" {  
                return nil, fmt.Errorf("[Config] [acceptor] Invalid identifier: %s", role)  
             } else {  
                identifier, err = strconv.Atoi(idStr)  
                if err != nil {  
                   return nil, fmt.Errorf("[Config] [acceptor] Invalid role identifier: %s", role)  
                }  
             }  
          } else if strings.HasPrefix(role, "learner") {  
             //3 : LEARNER  
             roleType = LEARNER  
             idStr := strings.TrimPrefix(role, "learner")  
             if idStr == "" {  
                return nil, fmt.Errorf("[Config] [learner] Invalid identifier: %s", role)  
             } else {  
                identifier, err = strconv.Atoi(idStr)  
                if err != nil {  
                   return nil, fmt.Errorf("[Config] [learner] Invalid role identifier: %s", role)  
                }  
             }  
          } else {  
             return nil, fmt.Errorf("[Config] Unknown role type: %s", role)  
          }  
  
          // Add to Roles map  
          rolesMap[identifier] = MessageStatus{  
             RoleType:        roleType,  
             PrepareSent:     false,  
             PrepareReceived: false,  
             AcceptSent:      false,  
             AcceptReceived:  false,  
          }  
       }  
  
       //HOSTNAME -> IP  
       var ip string  
       for {  
          ip, err = getIP(hostname)  
          if err == nil {  
             break  
          }  
          time.Sleep(DNS_REQUEST_DELAY) // Retry after delay = Too fast? DNS WILL NOT RESPOND!  
       }  
       if err != nil {  
          //If failed  
          return nil, fmt.Errorf("[Config] could not resolve IP for host: %s", hostname)  
       }  
  
       port := DEFAULT_PORT //In case not working!  
       peer := &Peer{  
          PeerID:   rowNumber,  
          IP:       ip,  
          Port:     port,  
          Hostname: hostname,  
          IsSelf:   hostname == currentHostname,  
          Roles:    rolesMap,  
       }  
  
       peerMap.AddPeer(peer)  
       rowNumber++  
    }  
  
    if err := scanner.Err(); err != nil {  
       return nil, fmt.Errorf("[CONFIG] ERROR READING FILE!: %v", err)  
    }  
  
    log_message(VERBOSE_DEBUG, "[Config] Total [%d] Hosts loaded.\n", len(peerMap.Peers))  
    return peerMap, nil  
}  
  
func getIP(hostname string) (string, error) {  
  
    ip_list, err := net.LookupIP(hostname)  
    if err != nil || len(ip_list) == 0 {  
       return "", err  
    }  
    return ip_list[0].String(), nil // First IP Address  
} // Hostname -> IP https://pkg.go.dev/net#LookupIP  
  
func getSelfHostname() (string, error) {  
    hostname, err := os.Hostname()  
    //If Hostname is nout in the OS  
    if err != nil {  
       return "", err  
    }  
    return hostname, nil  
} // Get my hostname https://pkg.go.dev/os#Hostname  
func printHosts(peerMap *PeerMap) {  
    peerMap.Mutex.Lock()  
    defer peerMap.Mutex.Unlock()  
  
    log_message(VERBOSE_INFO, "%-6s %-12s %-8s %-10s %-15s %-10s\n", "SrcID", "IP", "Port", "Hostname", "IsSelf", "Roles")  
    for _, peer := range peerMap.Peers {  
       //Role -> String  
       //Temporary List       rolesStr := []string{}  
  
       for id, status := range peer.Roles {  
          roleName := ""  
          switch status.RoleType {  
          case PROPOSER:  
             roleName = fmt.Sprintf("proposer[%d]", id)  
          case ACCEPTOR:  
             roleName = fmt.Sprintf("acceptor[%d]", id)  
          case LEARNER:  
             roleName = fmt.Sprintf("learner[%d]", id)  
          }  
          rolesStr = append(rolesStr, roleName)  
       }  
  
       log_message(VERBOSE_INFO, "%-6d %-12s %-8d %-10s %-15t %-10s\n", peer.PeerID, peer.IP, peer.Port, peer.Hostname, peer.IsSelf, strings.Join(rolesStr, ", ")) // New Line!  
    }  
}  
  
func printSendReceive(msg Message, action string) {  
    if !submissionSurpress {  
       log_message(VERBOSE_SUBMISSION, "{\"peer_id\":%d, \"action\": \"%s\", \"message_type\":\"%s\",\"message_value\":\"%c\", \"proposal_num\":%s}\n",  
          msg.SrcID,  
          action,  
          msg.MessageType.String(),  
          msg.MessageValue,  
          msg.ProposalNumber)  
    }  
}  
  
/*  
TCP Communication Server/Client  
*/  
//Server  
func startTCPServer(peer *Peer, peerMap *PeerMap) {  
    //1. TCP Listener  
    listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", peer.IP, peer.Port))  
    if err != nil {  
       log_message(VERBOSE_ERROR, "startTCPServer() Error starting TCP server:", err)  
       return  
    }  
  
    //A. When function ends, listening closed  
    defer listener.Close()  
    log_message(VERBOSE_INFO, "startTCPServer() TCP server started %s:%d\n", peer.IP, peer.Port)  
  
    //Accept -> GoRoutine(THRD) will do following jobs  
    //For is While in GO    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log_message(VERBOSE_ERROR, "startTCPServer() ERROR accepting connection", err)  
          continue  
       }  
       /*  
          *  GO Routine             Not completely a Thread but works like thread (Asynchronous)       */       go handleTCPConnection(conn, peer, peerMap)  
    }  
}  
func handleTCPConnection(conn net.Conn, peer *Peer, peerMap *PeerMap) {  
    /*  
       DECODER (Deserialization)    */    defer conn.Close() //Auto close  
  
    // Process incoming messages    decoder := gob.NewDecoder(conn) //Structs -> BYTES (not string)  
    var msg Message  
    err := decoder.Decode(&msg)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "Error decoding message: %v\n", err)  
       return  
    }  
  
    // Handle the decoded message  
    log_message(VERBOSE_DEBUG, "Received message: %+v\n", msg)  
    handleMessage(msg, peer, peerMap)  
}  
func handleMessage(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       Classify and Toss the message into the each logic       Proposer          PREPARE_ACK          ACCEPT_ACK       Acceptor          PREPARE          ACCEPT    */    switch msg.MessageType {  
    /*  
       Proposer    */    case PREPARE_ACK:  
       printSendReceive(msg, "received")  
       handlePrepareACK(msg, peer, peerMap)  
    case ACCEPT_ACK:  
       printSendReceive(msg, "received")  
       handleAcceptACK(msg, peer, peerMap)  
    /*  
       Acceptor    */    case PREPARE:  
       printSendReceive(msg, "received")  
       handlePrepare(msg, peer, peerMap)  
    case ACCEPT:  
       printSendReceive(msg, "received")  
       handleAccept(msg, peer, peerMap)  
  
    default:  
       log_message(VERBOSE_ERROR, "(TCP_SERVER) handleMessage() UNKNOWN TYPE: [%v]\n", msg.MessageType)  
    }  
}  
  
/*  
    Proposer*/  
  
func handlePrepareACK(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       4) When responses received from majority:          If any accepted Values returned,          replace value with accepted Value for highest accepted Proposal  
       1. Receive       2. Record at ProposerTracker       3. Check if the response was received from the majority       4.1. If not go back to receive state       4.2. If received from the majority, Broadcast Accept(n, value) to all servers    */    //1. States Start    //printSendReceive(msg, "received")    aStart := time.Now()  
    proposerState := getProposerState(msg.SrcID)  
    if proposerState == nil || len(proposerStates) <= 0 {  
       log_message(VERBOSE_ERROR, "handlePrepareACK() proposerState Not found!\n")  
       return  
    }  
  
    //2. Mutex ON for the states  
    proposerState.Mutex.Lock()  
    defer proposerState.Mutex.Unlock()  
  
    //3.MSG -> Proposal Number struct  
    acceptedProposalNumber, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handlePrepareACK() Invalid Proposal Number Parsing failed: %v\n", err)  
       return  
    }  
  
    //4. Record at ProposerTracker  
    proposerState.PrepareResponses = &Proposal{  
       ProposalNumber: acceptedProposalNumber,  
       Value:          msg.MessageValue,  
    }  
  
    totalResponses := CountPrepareResponses(proposerStates) // Total Response to calculate the quorum  
    totalPeers := len(peerMap.Peers)                        // Total Peers to calculate the peers  
    log_message(VERBOSE_DEBUG, "handlePrepareACK() TotalReponse/Peers = [%d/%d]\n", totalResponses, totalPeers)  
  
    //5. Quorum check (N/2)+1 Equation  
    if totalResponses >= ((totalPeers / 2) + 1) {  
       log_message(VERBOSE_DEBUG, "Quorum Formed! Prepare REDY! [%d/%d]\n", totalResponses, totalPeers)  
       /*  
          FIND THE HIGHEST PROPOSAL NUMBER & VALUE  
          1. Peers already have accepted higher proposal will ignore PREPARE anyway       */       highestNumber := proposerState.ProposalNumber // ME  
       highestValue := proposerState.Value           // MY VALUE  
  
       log_message(VERBOSE_DEBUG, "(Me) Proposal: %d Value: %d\n", highestNumber, highestValue)  
  
       statesHighestProposalNumber := ProposalNumber{}  
       statesHighestValue := byte(0)  
       log_message(VERBOSE_DEBUG, "Original Highest Proposal: %d Highest Value: %d\n", statesHighestProposalNumber, statesHighestValue)  
  
       //Find the highest number proposal with value in states (smaller than me anyway)  
       for i, prop := range proposerStates {  
          /*  
             1. Proposal Not exist in any response                >Propose with proposing value and new proposal number             2. Proposal Exist in 1 response                >Propose with existing value and new proposal number             3. Same Proposal Exist in all response                >Same as case 2                   >Propose with existing value and new proposal number             4. Different Proposal Exist in all response                >Find the highest Proposal Number and use that value but sending in a new proposal number  
             1. Once hits quorum, check if there's any inconsistent value/proposal in the state structure             2.1    If there's inconsistency detected, exception             2.2 If 1 unique value/proposal number found in state structure, use that (Multi/Single)          */          log_message(VERBOSE_DEBUG, "[%d] Current Proposer State : %+v\n", i, prop.PrepareResponses)  
  
          //Original  
          //if prop.ProposalNumber.GreaterThan(highestNumber) {          // log_message(VERBOSE_ERROR, "handlePrepareACK() If %v > %v then minProposal = %v \n", highestNumber, peer.minProposal, highestNumber)          //          // //If the Proposal Number is bigger than previous highest one? Update.          // highestNumber = prop.PrepareResponses.ProposalNumber          // highestValue = prop.PrepareResponses.Value          //}  
          //2. Find the biggest Proposal Number          log_message(VERBOSE_DEBUG, "handlePrepareACK() shpn:[%s] PROP.PREPARE.PN:[%s] \n", statesHighestProposalNumber.String(), prop.PrepareResponses.ProposalNumber.String())  
          if prop.PrepareResponses.ProposalNumber.GreaterThan(statesHighestProposalNumber) {  
             log_message(VERBOSE_DEBUG, "handlePrepareACK() If %v > %v then minProposal = %v \n", prop.PrepareResponses.ProposalNumber.String(), statesHighestProposalNumber.String(), prop.PrepareResponses.ProposalNumber.String())  
  
             //If the Proposal Number is bigger than previous highest one? Update.  
             statesHighestProposalNumber = prop.PrepareResponses.ProposalNumber  
             statesHighestValue = prop.PrepareResponses.Value  
             log_message(VERBOSE_DEBUG, "statesHighestProposalNumber:[%+v],statesHighestValue:[%c]\n", statesHighestProposalNumber, statesHighestValue)  
          }  
  
       }  
       log_message(VERBOSE_DEBUG, "states) Highest Proposal: %d Highest Value: %d\n", statesHighestProposalNumber, statesHighestValue)  
  
       //Compare with my proposenumber and value  
       //IF statesHighestProposalNumber is higher than highestNumber = NO       //If statesHighestProposalNumber is lower AND highestValue is different = Use the highestValue but keep my pn       log_message(VERBOSE_DEBUG, "statesHighestProposalNumber: %v,highestNumber: %v, statesHighestValue: %v, highestValue: %v \n", statesHighestProposalNumber, highestNumber, statesHighestValue, highestValue)  
       if !statesHighestProposalNumber.GreaterThan(highestNumber) && statesHighestProposalNumber != highestNumber && statesHighestValue != highestValue && statesHighestValue != byte(0) {  
          log_message(VERBOSE_DEBUG, "handlePrepareACK() OK : PN RECV<ME, SHV != HV, SHV != 0\n")  
          highestValue = statesHighestValue  
          proposerState.Value = highestValue  
       } else if statesHighestProposalNumber.GreaterThan(highestNumber) {  
          log_message(VERBOSE_ERROR, "handlePrepareACK() Me[%s] Received[%s]\n", statesHighestProposalNumber.String(), highestNumber.String())  
       }  
  
       log_message(VERBOSE_DEBUG, "Updated Highest Proposal: %d Highest Value: %d\n", highestNumber, highestValue)  
  
       // 4.2. If received from the majority, Broadcast Accept(n, value) to all servers  
       sortedDestination := peerMap.GetAllPeersSorted()  
       for _, acceptor := range sortedDestination {  
          pRole := acceptor.Roles[ROLE_ORDER]  
          if acceptor.PeerID == peer.PeerID {  
             //log_message(VERBOSE_DEBUG, "Acceptr> Skip myself.\n")  
             continue  
          }  
          //Send ACCEPT message only to the Acceptors and Learners  
          if pRole.RoleType == ACCEPTOR {  
             //log_message(VERBOSE_DEBUG, "Acceptr-ACCEPTOR> Dest[%d], pRole[%+v]\n", acceptor.PeerID, pRole)  
  
          } else if pRole.RoleType == LEARNER {  
             //log_message(VERBOSE_DEBUG, "Acceptr-LEARNER> Dest[%d], pRole[%+v]\n", acceptor.PeerID, pRole)  
          } else {  
             //log_message(VERBOSE_DEBUG, "Acceptr> Dest[%d], pRole[%+v]\n", acceptor.PeerID, pRole)  
             //log_message(VERBOSE_DEBUG, "Acceptr> Destination NOT Acceptor or Learner. Skipping.\n")             continue  
          }  
  
          acceptMsg := Message{  
             SrcID:          peer.PeerID,  
             DestID:         acceptor.PeerID,  
             MessageType:    ACCEPT,  
             ProposalNumber: highestNumber.String(),  
             MessageValue:   highestValue,  
          }  
          //printSendReceive(acceptMsg, "sent")  
          log_message(VERBOSE_DEBUG, "handlePrepareACK() ACCEPT sending to %d.\n", acceptor.PeerID)  
          err := SendMessage(acceptMsg, peer, peerMap)  
          if err != nil {  
             log_message(VERBOSE_ERROR, "handlePrepareACK() Send ACCEPT Failed : %v\n", err)  
          }  
          log_message(VERBOSE_DEBUG, "handlePrepareACK() Wait %f Seconds\n", ACCEPTOR_SEND_INTERVAL)  
          time.Sleep(ACCEPTOR_SEND_INTERVAL)  
       }  
       aDuration := time.Since(aStart)  
       log_message(VERBOSE_DEBUG, "ACCEPTOR DONE IN %.6f seconds\n", aDuration.Seconds())  
    }  
}  
func handleAcceptACK(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       7) When responses received from majority:          Any rejections (result > n)?  goto (1)          Otherwise, value is chosen  
       1. Receive       2. Record       3. Check if the response was received from the majority       4. Check if the response has any rejection {Any rejections (result > n)?  goto (1)}       4.1. If not = VALUE IS CHOSEN!       4.2. If there's any rejection? Go back to the 1st Phase {Proposer: 1) Choose new proposal number n}    */  
    //1. get proposerState    //printSendReceive(msg, "received")    proposerState := getProposerState(msg.SrcID)  
    if proposerState == nil {  
       //Non acceptor is not counting towards quorum.  
       log_message(VERBOSE_DEBUG, "handleAcceptACK() can't find my state %d\n", msg.SrcID)  
       return  
    }  
  
    //2. proposerState MUTEX  
    proposerState.Mutex.Lock()  
    defer proposerState.Mutex.Unlock()  
  
    //3. MSG -> Proposal Number struct  
    proposalNum, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handleAcceptACK() ParseProposalNumber() error\n")  
    }  
    proposerState.AcceptResponses = &Proposal{  
       ProposalNumber: proposalNum,  
       Value:          msg.MessageValue,  
    }  
  
    totalResponses := CountAcceptResponses(proposerStates) // Total Response to calculate the quorum  
    totalPeers := len(peerMap.Peers)                       // Total Peers to calculate the peers  
    log_message(VERBOSE_DEBUG, "handleAcceptACK() TotalReponse/Peers = [%d/%d]\n", totalResponses, totalPeers)  
  
    //3. Check if the response was received from the majority  
    if totalResponses >= (totalPeers/2)+1 {  
       log_message(VERBOSE_DEBUG, "Quorum Formed! Accept REDY! [%d/%d]\n", totalResponses, totalPeers)  
       // Any rejections (result > n)?  goto (1)  
  
       // Otherwise, value is chosen       log_message(VERBOSE_INFO, "handleAcceptACK() Value '%c' was chosen with Proposal Number [%s]!\n", proposerState.Value, proposerState.ProposalNumber.String())  
       peer.acceptedValue = proposerState.Value  
       peer.acceptedProposal = proposerState.ProposalNumber  
       log_message(VERBOSE_SUBMISSION, "{\"peer_id\":%d "+  
          "\"action\": \"chose\",\"message_type\":\"chose\",\"message_value\":\"%c\","+  
          "\"proposal_num\":%s}\n",  
          peer.PeerID, peer.acceptedValue, peer.acceptedProposal.String())  
       //Reset Proposer Tracker  
       proposerStates = nil  
    }  
}  
  
/*  
Acceptor  
*/  
func handlePrepare(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       3) Respond to Prepare(n):          If n > minProposal then minProposal = n          Return(acceptedProposal, acceptedValue)  
       1. Check If received n is bigger than minProposal          then change minProposal value into received n       2. Respond server with acceptedProposal, acceptedValue message=    */    //1. MSG -> Proposal Number struct    //printSendReceive(msg, "received")  
    n, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handlePrepare() Invalid Proposal Number Parsing failed: %v\n", err)  
       return  
    }  
  
    //2. Peer MUTEX  
    peer.Mutex.Lock()  
    defer peer.Mutex.Unlock()  
  
    // 3. If n > minProposal then minProposal = n  
    if n.GreaterThan(peer.minProposal) {  
       log_message(VERBOSE_ERROR, "handlePrepare() If %v > %v then minProposal = %v \n", n, peer.minProposal, n)  
       //then minProposal = n  
       peer.minProposal = n  
       // 4. Message Creation  
       response := Message{  
          SrcID:          peer.PeerID,  
          DestID:         msg.SrcID,  
          MessageType:    PREPARE_ACK,  
          ProposalNumber: peer.acceptedProposal.String(), //Proposal -> String  
          MessageValue:   peer.acceptedValue,  
       }  
       // 5. Message Transmission  
       //printSendReceive(response, "sent")       err := SendMessage(response, peer, peerMap)  
       if err != nil {  
          log_message(VERBOSE_ERROR, "handlePrepare() Send failed : %v\n", err)  
       }  
  
    } else {  
       // 6. PREPARE message ignore  
       log_message(VERBOSE_DEBUG, "handlePrepare() PREPARE Ignored: n=%s (minProposal=%s)\n", n.String(), peer.minProposal.String())  
    }  
}  
func handleAccept(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       6. Respond to Accept(n, value):          If n ≥ minProposal then             acceptedProposal = minProposal = n             acceptedValue = value          Return(minProposal)  
       1.1If received n is bigger or same as  minProposal          2.1 then change acceptedProposal value into proposed proposal number n          2.2 change minProposal vlaue into proposed proposal number n          2.3 change acceptedValue as proposed value          3. Respond server with minProposal  
       1.2 If received n is NOT bigger or same as  minProposal          Ignore  
    */    //1. MSG -> Proposal Number struct    //printSendReceive(msg, "received")  
    n, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handleAccept() Invalid Proposal Number Parsing failed: %v\n", err)  
       return  
    }  
  
    //2. Peer MUTEX  
    peer.Mutex.Lock()  
    defer peer.Mutex.Unlock()  
  
    // 3. If n ≥ minProposal then  
    // acceptedProposal = minProposal = n    // acceptedValue = value    if n.GreaterThanOrEqual(peer.minProposal) {  
       rolesSorted := peer.GetSortedRoles()  
       if len(rolesSorted) <= 0 {  
          log_message(VERBOSE_ERROR, "RolesSorted Not Exist NO roles found\n")  
          return  
       }  
  
       log_message(VERBOSE_DEBUG, "handleAccept() n ≥ minProposal\n")  
       peer.minProposal = n                  // acceptedProposal = minProposal = n  
       peer.acceptedProposal = n             // acceptedProposal = minProposal = n  
       peer.acceptedValue = msg.MessageValue // acceptedValue = value  
       log_message(VERBOSE_DEBUG, "ACCEPTED!  acceptedProposal:%d,acceptedValue:%d\n", peer.acceptedProposal, peer.acceptedValue)  
  
       if rolesSorted[0].RoleType == LEARNER {  
          log_message(VERBOSE_ERROR, "I am the Learner! NO MESSAGE WILL BE SENT!\n")  
          return  
       }  
  
       // 4. Message Creation  
       response := Message{  
          SrcID:          peer.PeerID,  
          DestID:         msg.SrcID,  
          MessageType:    ACCEPT_ACK,  
          ProposalNumber: peer.minProposal.String(),  
       }  
  
       err := SendMessage(response, peer, peerMap)  
       if err != nil {  
          log_message(VERBOSE_ERROR, "handleAccept() Send failed : %v\n", err)  
       }  
    } else {  
       // 6. PREPARE message ignore  
       log_message(VERBOSE_DEBUG, "handleAccept() PREPARE Ignored: n=%s (minProposal=%s)\n", n.String(), peer.minProposal.String())  
    }  
}  
  
// Client  
func SendMessage(message Message, peer *Peer, peerMap *PeerMap) error {  
    /*  
       Message to extract DestID    */    //1. Dest Info Extraction    destPeer, _ := peerMap.GetPeer(message.DestID)  
    if destPeer == nil {  
       return fmt.Errorf("SendMessage() Peer Not Found")  
    }  
    destPeerID := destPeer.PeerID  
    destPeerIP := destPeer.IP  
    destPeerPort := destPeer.Port  
  
    //2.Connect  
    address := fmt.Sprintf("%s:%d", destPeerIP, destPeerPort)   // Make [IP]:[PORT]  
    conn, err := net.DialTimeout("tcp", address, 1*time.Second) // Time Out 1 SEC  
  
    if err != nil {  
       return err  
    }  
    defer conn.Close()  
  
    //3.Encode to bytes  
    encoder := gob.NewEncoder(conn)  
    if err := encoder.Encode(message); err != nil {  
       log_message(VERBOSE_ERROR, "Failed to send message to peer %d: %v\n", destPeerID, err)  
       return err  
    }  
    log_message(VERBOSE_DEBUG, "Sent message: %+v\n", message)  
    printSendReceive(message, "sent")  
    return nil  
}  
  
func runProposer(peer *Peer, peerMap *PeerMap, roundNumber int, value byte) {  
    /*  
       1. Choose new proposal number n (Use the one from the Peer.Roles int) ex:) 1 or 2       2. Creating a global ProposerTracker struct          1. Create a new ProposalNumber based on round number (roles.int) and serverID (my peer ID)          2. Add proposerID          3. Fill the ProposedValue from the CLI       2. Broadcast Prepare(n) to all servers          n = Proposal Number (RoundNumber.ServerID)    */    pStart := time.Now()  
    // 2. Broadcast Prepare(n) to all servers  
    sortedDestination := peerMap.GetAllPeersSorted()  
    for _, entity := range sortedDestination {  
       acceptor, res := peerMap.GetPeer(entity.PeerID)  
       if !res {  
          return  
       }  
       //Skip my self  
       if acceptor.PeerID == peer.PeerID {  
          continue  
       }  
       if entity.Roles[roundNumber].RoleType == ACCEPTOR {  
  
          //1. Choose new proposal number n (Use the one from the Peer.Roles int) ex:) 1 or 2  
          proposalNumber := ProposalNumber{  
             RoundNumber: roundNumber,  
             ServerID:    peer.PeerID,  
          }  
          //2. Creating a  Proposer State Tracker struct  
          proposerState := &ProposerState{  
             ProposalNumber:   proposalNumber,  
             Value:            value,  
             PrepareResponses: nil,  
             AcceptResponses:  nil,  
          }  
  
          storeProposerState(acceptor.PeerID, proposerState)  
          prepareMsg := Message{  
             SrcID:          peer.PeerID,  
             DestID:         acceptor.PeerID,  
             MessageType:    PREPARE,  
             ProposalNumber: proposalNumber.String(),  
          }  
          //printSendReceive(prepareMsg, "sent")  
          log_message(VERBOSE_DEBUG, "runProposer() PREPARE sending to %d.\n", entity.PeerID)  
          err := SendMessage(prepareMsg, peer, peerMap)  
          if err != nil {  
             log_message(VERBOSE_ERROR, "runProposer() PREPARE send failed: %v\n", err)  
          }  
          log_message(VERBOSE_DEBUG, "runProposer() Waiting for %f seconds\n", PROPOSER_SEND_INTERVAL)  
          time.Sleep(PROPOSER_SEND_INTERVAL)  
       }  
    }  
    pDuration := time.Since(pStart)  
    log_message(VERBOSE_DEBUG, "PROPOSER DONE IN %.6f seconds\n", pDuration.Seconds())  
}  
  
func main() {  
    START_TIME = time.Now()  
    var hostsFile string  
    var payloadValueTemp string  
  
    var delay float64  
  
    // Required  
    flag.StringVar(&hostsFile, "h", "", "REQUIRED! hostfile filename")  
    // Required If the peer is a proposer  
    flag.StringVar(&payloadValueTemp, "v", "X", "This is the value used if the peer is a proposer. It is a character.")  
    // Not required - TC2  
    flag.Float64Var(&delay, "t", -1, " This is the time in seconds proposer 2 will wait before starting its proposal with its value v. This will be needed for the second testcase scenario.")  
  
    flag.Parse()  
  
    var payloadValue byte = byte(payloadValueTemp[0])  
    if delay > 0 {  
       ROLE_ORDER = 2  
    }  
    /*  
       HOST INIT    */    // HostFile Load    if hostsFile == "" {  
       log_message(VERBOSE_ERROR, "NO HOSTSFILE PROVIDED. CHECK YOUR PARAMETER.")  
       return  
    }  
    peerMap, err := loadHosts(hostsFile)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "(main) HOSTFILE READER FAILED!: %v\n", err)  
       return  
    }  
    printHosts(peerMap)  
  
    // Self Detection  
    var selfPeer *Peer  
    selfPeer, _ = GetPeerSelf(peerMap)  
    if selfPeer == nil {  
       log_message(VERBOSE_ERROR, "(main) I can't find myself")  
       return  
    }  
  
    /*  
       SERVER INIT    */  
    go startTCPServer(selfPeer, peerMap)  
    log_message(VERBOSE_DEBUG, "main() SERVER STARTED!\n")  
    /*  
       CLIENT INIT    */    // Am I a Proposer? -> peers.roles    time.Sleep(2 * time.Second) // Delay  
    for _, status := range selfPeer.Roles {  
       if status.RoleType == PROPOSER {  
          log_message(VERBOSE_DEBUG, "main() I am the proposer!\n")  
          //Test case 2 (Wait)  
          if delay > 0 {  
             log_message(VERBOSE_DEBUG, "main() I am the proposer Test Case 2!\n")  
             time.Sleep(time.Duration(delay) * time.Second)  
          }  
          value := payloadValue  
          go runProposer(selfPeer, peerMap, 1, value)  
       }  
    }  
    select {}  
}
And write
- Overview
- Algorithm Details
- Data Structures
- Proposal and Proposal Number
- Proposer State Management
- Implementation Details
- handleNewLeader
- Output Messages