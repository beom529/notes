Here's the task description

1. Task
In this lab, you will implement a normal operation of Paxos, but without a leader, where two proposers are trying to get their proposals to succeed. This is similar to the example from slide 46 from the Paxos slides. We will refer to all servers as peers.

Each peer starts by knowing a list representing the set of peers that are part of this Paxos configuration. Peer ids will be assigned based on the line in the file, starting at 1. To make it easier, you will specify in the configuration file, what role a peer has: proposer, acceptor, learner.

First you will implement normal Paxos operation where the process with the lowest id will try to propose a value and nothing goes wrong. Follow the description of the variables from slide 45. The second case you will implement is when both peer1 and peer2 submit a proposal.

At the end, all peers should print the chosen value. You can assume that the number of peers is 5. You should test your code with 5 nodes and provide the testcases described below.

You can use C/C++, Java, or Go. Communication can be implemented with TCP. Communi- cation should be reliable. All messages must be printed verbatim—they should all be valid JSON strings.
1. PART 1: Normal operation of Paxos with 1 proposer
After all peers have started, the peer with the lowest id will initiate a proposal and perform the Paxos normal operation as described in slide 45. Each peer will print on the screen what message they sent and what message they received. Note that from the configuration file, a peer will know if it is an acceptor or not. This will help with minimizing the number of messages that are sent. The proposer will communicate only with its acceptors as defined in the configuration file. For example, you can configure that peer2 and peer3 are acceptors for proposer peer1. You don’t need to worry about the learners learning the value.

Sent and received messages should be of the following format, where <TEXT> should be replaced with your program-specific values. Message type can be one of: “prepare”, “prepare ack”, “accept”, “accept ack”. Action should either be “sent” or “received”. Message value should be “X” or “Y”.

{"peer_id":<SENDER_ID>, "action": "<ACTION>",
"message_type":"<TYPE>",
"message_value":"<VALUE>",

 "proposal_num":<PROPOSAL_NUMBER>}

Example:

{"peer_id": 1, "action": "sent",
"message_type":"prepare_ack",
"message_value":"X",
"proposal_num":5}

When a value is chosen by a peer, it should print the following:

{"peer_id":<SENDER_ID>, "action": "chose",
"message_type":"chose",
"message_value":"<VALUE>",
"proposal_num":<PROPOSAL_NUMBER>}

Example:

{"peer_id":3, "action": "chose",
"message_type":"chose",
"message_value":"Y",
"proposal_num":7}

TESTCASE 1: All peers start, peer with the lowest id initiates a proposal with a value X given through the command line. All peers print the messages they receive and send. (Peers that are not involved in the protocol print nothing). All peers that participate in the protocol should agree on value X.
1. PART 2: Two competing proposals with different values
In this part, there will be two proposers that will try to push their own value independently of each other. In this case, you will need another configuration file where you specify who the acceptors are for proposer 1 (the peer with the lowest id, peer1) and for proposer 2 (the peer with the highest id, peer5), like the example in the slides, peer2 and peer3 will work with proposer 1 (peer1) and peer3 and peer4 will work with proposer 2 (peer5).

The key here is that peer5 should initiate the proposal after peer3 sends the accept to the proposal from peer1—as in the example in slide 46. All peers should end up with value X, even if peer5 was trying to push value Y.

To control when peer5 starts its proposal, you can use a timeout. From testcase 1 you will have some idea how long it takes for proposal 1 to complete.

TESTCASE 2: Peer1 starts with value X, after peer3 answers with accept to peer1’s proposal, peer5 starts a proposal with value Y. All peers should agree on value X. The same printed messages should be used as in part 1.

Implementation
You need to implement this algorithm in C/C++, Java, or Go, and your implementation must allow the user to configure the execution of the process. You will again be using Docker to package your program. Additionally, you must use Docker Compose as a container orchestrator. Instructions on how to use Docker Compose are provided in the Docker Tutorial. You will be provided with a Docker Compose file for each of the two testcases. You must be able to run each of the Compose configurations and see the expected outputs printed to the screen. The expected interface for your containers is provided below. If you adhere to this interface, then Docker Compose will work seamlessly, without any changes.

You will also receive a hostsfile.txt specifying the hosts and roles of the five peers for each testcase. You may test on your own hostsfiles, but to receive full credit, your code must be compatible with the one provided. The hostsfile has the following format. Each line starts with the hostname of the peer followed by a colon. To the right of the colon is a comma-separated list of the roles that peer fills. If the roles are specific to a peer, then the role is appended with a numeric identifier. For example, the acceptors of proposer1 have the role acceptor1. An example hostsfile

may look like the following

  peer1:proposer1
  peer2:acceptor1,acceptor2
  peer3:acceptor1,acceptor2
  peer4:acceptor1,learner1
  peer5:proposer2

Note: you must implement all CLI arguments exactly as written below to receive full credit.

parameter
 -h hostsfile
      The hostsfile is the path to a file that contains
      the list of hostnames that the processes are
      running on. It assumes that each host is running
      only one instance of the process.
      ...

      All the processes will listen on the same port.
      The line number indicates the identifier of the process
      which starts at 1.

   -v value
      This is the value used if the peer is a proposer. It is a character.

   -t delay
      This is the time in seconds proposer 2 will wait before starting its proposal with its value v. This will be needed for the second testcase scenario.

2. Here's my code
package main  
  
import (  
    "bufio"  
    "encoding/gob"    "flag"    "fmt"    "net"    _ "net/http/pprof"  
    "os"    "sort"    "strconv"    "strings"    "sync"    "time")  
  
// Global Variables  
// https://pkg.go.dev/time#Duration  
var (  
    DEFAULT_PORT int           = 3000  
    DELAY        time.Duration = 0 * time.Second  
    //DNS Request Failed and retry to retrieve hostname  
    DNS_REQUEST_DELAY      time.Duration = 1500 * time.Millisecond  
    ROLE_ORDER                           = 1  
    START_TIME                           = time.Time{}  
    PROPOSER_SEND_INTERVAL               = 2500 * time.Millisecond  
    ACCEPTOR_SEND_INTERVAL               = 2000 * time.Millisecond  
)  
  
// Logger  
// type VerboseLevel int  
const (  
    VERBOSE_SUBMISSION = iota  
    VERBOSE_ERROR  
    VERBOSE_WARNING    VERBOSE_INFO    VERBOSE_DEBUG)  
  
var currentVerboseLevel = VERBOSE_DEBUG  
var submissionSurpress = true  
  
var logMessageMutex sync.Mutex  
  
func log_message(verboseLevel int, format string, args ...interface{}) {  
    logMessageMutex.Lock()  
    defer logMessageMutex.Unlock()  
  
    if currentVerboseLevel == VERBOSE_DEBUG {  
       //https://jeonghwan-kim.github.io/dev/2019/01/14/go-time.html weird time specifier  
       now := time.Since(START_TIME)  
       seconds := int(now.Seconds()) % 60  
       milliseconds := int(now.Milliseconds()) % 1000  
       formattedTime := fmt.Sprintf("%02d.%04d ", seconds, milliseconds)  
  
       fmt.Fprintf(os.Stderr, formattedTime)  
    }  
    if verboseLevel <= currentVerboseLevel {  
       // stderr  
       fmt.Fprintf(os.Stderr, format, args...)  
    }  
}  
  
// Message (Payload) Structtype Message struct {  
    SrcID  int //SrcID for the source  
    DestID int //DestID for the destination  
    /*       1.Broadcast Prepare(n) to all servers          MessageType : PREPARE          ProposalNumber : RoundNumber.ServerID  
       2.Respond to Prepare(n)          MessageType : PREPARE_ACK  
          ProposalNumber: If Exist (RoundNumber.ServerID) If NOT NIL or equivalent          MessageValue : If Exist (Char) IF NOT NIL or equivalent  
       3.Broadcast Accept(n, value) to all servers          MessageType : PREPARE_ACK  
          ProposalNumber : RoundNumber.ServerID (Accepted One)          MessageValue : A Character (Accepted One)  
       4.Respond to Accept(n, value)       MessageType : ACCEPT_ACK  
  
       ProposalNumber : RoundNumber.ServerID (MinProposal)    */    MessageType    MessageType //Enum  
    ProposalNumber string      // Proposal Num -> String : On the network uses string but internally, uses Proposal Number in a data structure    MessageValue   byte        //A single char value specified in the instruction  
}                    // Message Structtype MessageType int // Message Type TYPEconst (  
    PREPARE MessageType = iota // 0  
    PREPARE_ACK  
    ACCEPT    ACCEPT_ACK) // Message Type ACTUAL ENUMfunc (messageType MessageType) String() string {  
    switch messageType {  
    case PREPARE:  
       return "prepare"  
    case PREPARE_ACK:  
       return "prepare_ack"  
    case ACCEPT:  
       return "accept"  
    case ACCEPT_ACK:  
       return "accept_ack"  
    default:  
       return "unknown"  
    }  
}  
  
/*  
Proposal Management*/  
type Proposal struct {  
    ProposalNumber ProposalNumber  
    Value          byte  
} // Proposal Structtype ProposalNumber struct {  
    //Proposal Number = RoundNumber + ServerID  
    //Actual Value = RoundNumber.ServerID like 1.1, 5.5  
    //Lamport clock solution - ProcessID    RoundNumber int  
    ServerID    int  
}  
  
/*  
Interfaces : https://go.dev/tour/methods/9  
Interfaces : https://gobyexample.com/interfaces  
*/  
func (pn ProposalNumber) GreaterThan(other ProposalNumber) bool {  
    if pn.RoundNumber > other.RoundNumber {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number\n")  
       return true  
    } else if pn.RoundNumber == other.RoundNumber && pn.ServerID > other.ServerID {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number = Server >\n")  
       return true  
    }  
    return false  
}  
func (pn ProposalNumber) LessThan(other ProposalNumber) bool {  
    if pn.RoundNumber < other.RoundNumber {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number\n")  
       return true  
    } else if pn.RoundNumber == other.RoundNumber && pn.ServerID < other.ServerID {  
       //log_message(VERBOSE_DEBUG, "GreaterThan() Round Number = Server >\n")  
       return true  
    }  
    return false  
}  
func (pn ProposalNumber) IsEmpty() bool {  
    return pn.RoundNumber == 0 && pn.ServerID == 0  
}  
func (pn ProposalNumber) Equal(other ProposalNumber) bool {  
    return pn.RoundNumber == other.RoundNumber && pn.ServerID == other.ServerID  
}  
func (pn ProposalNumber) GreaterThanOrEqual(other ProposalNumber) bool {  
    return pn.GreaterThan(other) || pn.Equal(other)  
}  
  
func (pn ProposalNumber) String() string {  
    return fmt.Sprintf("%d.%d", pn.RoundNumber, pn.ServerID)  
} // to string  
  
func ParseProposalNumber(s string) (ProposalNumber, error) {  
    parts := strings.Split(s, ".")  
    if len(parts) != 2 {  
       return ProposalNumber{}, fmt.Errorf("invalid format: %s", s)  
    }  
  
    roundNumber, err := strconv.Atoi(parts[0])  
    if err != nil {  
       return ProposalNumber{}, fmt.Errorf("invalid round number: %s", parts[0])  
    }  
  
    serverID, err := strconv.Atoi(parts[1])  
    if err != nil {  
       return ProposalNumber{}, fmt.Errorf("invalid server ID: %s", parts[1])  
    }  
  
    return ProposalNumber{  
       RoundNumber: roundNumber,  
       ServerID:    serverID,  
    }, nil  
} // to struct  
  
/*  
    Peer Management*/  
  
// Peer Structtype Peer struct {  
    PeerID   int    // PeerID - row number    IP       string // IP address    Port     int    // Port Number    Hostname string // Hostname  
    IsSelf   bool   // is Self?  
    //Lab4    //IsProposer bool //Proposer Flag    //IsAcceptor bool //Acceptor Flag    //IsLearner  bool //Learner Flag    //To pass Testcase2, Made a Map    //int = Round Number    Roles map[int]MessageStatus //Parses Hostsfile entities ends with integer. [INT] = Role  
  
    //PAXOS    Mutex            sync.Mutex     //  
    minProposal      ProposalNumber //minProposal specified in the algorithm  
    acceptedProposal ProposalNumber //acceptedProposal specified in the algorithm  
    acceptedValue    byte           //acceptedValue specified in the instruction. Unlike C GO uses byte to represent a single char. (ASCII)  
}  
  
func (peer *Peer) GetSortedRoles() []MessageStatus {  
  
    // 1. Roles to Slice  
    roleKeys := make([]int, 0, len(peer.Roles))  
    for key := range peer.Roles {  
       roleKeys = append(roleKeys, key)  
    }  
  
    // 2. Sorts  
    sort.Ints(roleKeys)  
  
    // 3. Adds Sorted Peer into the list  
    sortedRoles := make([]MessageStatus, 0, len(peer.Roles))  
    for _, key := range roleKeys {  
       sortedRoles = append(sortedRoles, peer.Roles[key])  
    }  
  
    return sortedRoles  
}  
  
// Message Structtype MessageStatus struct {  
    RoleType        RoleType //Role Type [ACCEPTOR,PROPOSER,LEARNER]  
    PrepareSent     bool     //PREPARE message  
    PrepareReceived bool     //PREPARE_ACK message  
    AcceptSent      bool     //ACCEPT message  
    AcceptReceived  bool     //ACCEPT_ACK message  
}  
  
// Role Struct  
type RoleType int  
  
const (  
    UNKNOWN RoleType = iota  
    PROPOSER  
    ACCEPTOR    LEARNER)  
  
type PeerMap struct {  
    Peers map[int]*Peer // PeerID : Peer Struct    Mutex sync.Mutex    // MUTEX to prevent concurrency issue  
}  
  
// NEW  
func NewPeerMap() *PeerMap {  
    //Creating a peer map  
    return &PeerMap{  
       Peers: make(map[int]*Peer),  
    }  
}  
  
// ADD  
func (peermap *PeerMap) AddPeer(peer *Peer) {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    //Peermap : Individual  
    peermap.Peers[peer.PeerID] = peer  
}  
  
// UPDATE  
func (peermap *PeerMap) UpdatePeer(peer *Peer) {  
    //Separted from Add case I need to add other logic in it  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    //Peermap : Individual  
    peermap.Peers[peer.PeerID] = peer  
}  
  
// DELETE  
func (peermap *PeerMap) DeletePeer(peerID int) {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    delete(peermap.Peers, peerID) // Peer Delete  
}  
  
// GET  
func (peermap *PeerMap) GetPeer(peerID int) (*Peer, bool) {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
    peer, exists := peermap.Peers[peerID]  
    return peer, exists  
}  
  
// Find my self  
func GetPeerSelf(peerMap *PeerMap) (*Peer, error) {  
    peerMap.Mutex.Lock()  
    defer peerMap.Mutex.Unlock()  
  
    //Ittr each object in the map and return peer(pointer)  
    for _, peer := range peerMap.Peers {  
       if peer.IsSelf {  
          return peer, nil  
       }  
    }  
    return nil, fmt.Errorf("Where am I?\n")  
}  
  
// Map -> Sorted List  
func (peermap *PeerMap) GetAllPeersSorted() []*Peer {  
    peermap.Mutex.Lock()  
    defer peermap.Mutex.Unlock()  
  
    // 1. PeerID to Slice  
    peerIDs := make([]int, 0, len(peermap.Peers))  
    for peerID := range peermap.Peers {  
       peerIDs = append(peerIDs, peerID)  
    }  
  
    // 2. Sorts  
    // https://pkg.go.dev/sort#Ints    sort.Ints(peerIDs)  
  
    // 3. Adds Sorted Peer into the list  
    sortedPeers := make([]*Peer, 0, len(peermap.Peers))  
    for _, id := range peerIDs {  
       sortedPeers = append(sortedPeers, peermap.Peers[id])  
    }  
  
    return sortedPeers  
}  
  
/*  
ProposerState Tracker  
    proposerStates[AcceptorID] = individual transaction  
Proposer creates this map to tracking PREPARE_ACK, ACCEPT_ACK value.1. When Proposer send message -> Create Entity in the map.  
2. When Proposer receive message -> Record  
3. When Proposer is COMMITTED with a value -> Reset  
*/  
var proposerProposal Proposal = Proposal{  
    ProposalNumber: ProposalNumber{  
       RoundNumber: 1,  
       ServerID:    1,  
    },  
    Value: byte(0),  
}  
  
type ProposerState struct {  
    Mutex sync.Mutex  
    //1.ProposalNumber and Value used during the process (init)    ProposalNumber ProposalNumber  
    Value          byte  
  
    //2.Prepare() Return(acceptedProposal, acceptedValue) Tracking  
    PrepareResponses *Proposal  
  
    //3.Accept() Return(minProposal) Tracking  
    AcceptResponses *Proposal  
}  
  
var proposerStates = make(map[int]*ProposerState)  
var proposerStatesMutex sync.Mutex  
  
func getProposerState(destID int) *ProposerState {  
    proposerStatesMutex.Lock()  
    defer proposerStatesMutex.Unlock()  
    return proposerStates[destID]  
} // In case Additional verification  
func storeProposerState(destID int, state *ProposerState) {  
    proposerStatesMutex.Lock()  
    defer proposerStatesMutex.Unlock()  
    log_message(VERBOSE_DEBUG, "storeProposerState() storing %d's proposer state.\n", destID)  
    proposerStates[destID] = state  
} //Init  
  
// PREPARE_ACK  
func CountPrepareResponses(proposerStates map[int]*ProposerState) int {  
    //1. Total Count is 0 = NON  
    totalCount := 0  
    //2. Count PrepareResponses  
    for _, state := range proposerStates {  
       if state.PrepareResponses != nil {  
          totalCount++  
       }  
    }  
    return totalCount  
}  
  
// ACCEPT_ACK  
func CountAcceptResponses(proposerStates map[int]*ProposerState) int {  
    //1. Total Count is 0 = NON  
    totalCount := 0  
    //2. Count AcceptResponses  
    for _, state := range proposerStates {  
       if state.AcceptResponses != nil {  
          totalCount++  
       }  
    }  
    return totalCount  
}  
  
/*  
    GENERAL UTILS*/  
// File -> PeerList  
func loadHosts(filename string) (*PeerMap, error) {  
    log_message(VERBOSE_DEBUG, "1. [CONFIG] READING A HOSTFILE\n")  
  
    //1. Open file  
    file, err := os.Open(filename)  
    if err != nil {  
       return nil, fmt.Errorf("no file detected: %v", err)  
    }  
    defer file.Close() //Automatically Close the file  
  
    peerMap := NewPeerMap()           //New Peer Map!  
    scanner := bufio.NewScanner(file) //Scanner  
    rowNumber := 1  
  
    currentHostname, err := getSelfHostname()  
    if err != nil {  
       return nil, fmt.Errorf("[CONFIG] could not get current hostname: %v", err)  
    }  
  
    for scanner.Scan() { //Everyline  
       line := strings.TrimSpace(scanner.Text())  
  
       if line == "" {  
          //Empty Line Skip  
          continue  
       }  
  
       //Left(Hostname) : Right(Roles)  
       parts := strings.Split(line, ":")  
       if len(parts) != 2 {  
          //If there's more than 2 or less than 2 strings = Error  
          log_message(VERBOSE_ERROR, "[Config] INCORRECT LINE: %s", line)  
          return nil, fmt.Errorf("[Config] INCORRECT LINE: %s", line)  
       }  
  
       //String:Left(0) = Hostname  
       hostname := strings.TrimSpace(parts[0])  
       //String:Right(1) = Role"S"  
       roles := strings.Split(strings.TrimSpace(parts[1]), ",")  
  
       //1. Map Creation  
       rolesMap := make(map[int]MessageStatus)  
       //2. Role Parsing (i,entity)  
       for _, role := range roles {  
          role = strings.TrimSpace(role) //White Space Separate  
          if role == "" {  
             continue  
          }  
  
          // Roletype, Identifier(index)  
          var roleType RoleType  
          var identifier int  
  
          //String Process  
          //3 : PROPOSER          //https://pkg.go.dev/strings#HasPrefix          if strings.HasPrefix(role, "proposer") {  
             roleType = PROPOSER  
             idStr := strings.TrimPrefix(role, "proposer") //String:integer  
             if idStr == "" {  
                return nil, fmt.Errorf("[Config] [proposer] Invalid identifier: %s", role)  
             } else {  
                //String -> Int  
                //https://pkg.go.dev/strconv                identifier, err = strconv.Atoi(idStr)  
                if err != nil {  
                   return nil, fmt.Errorf("[Config] [proposer] Invalid role identifier: %s", role)  
                }  
             }  
          } else if strings.HasPrefix(role, "acceptor") {  
             //3 : ACCEPTOR  
             roleType = ACCEPTOR  
             idStr := strings.TrimPrefix(role, "acceptor")  
             if idStr == "" {  
                return nil, fmt.Errorf("[Config] [acceptor] Invalid identifier: %s", role)  
             } else {  
                identifier, err = strconv.Atoi(idStr)  
                if err != nil {  
                   return nil, fmt.Errorf("[Config] [acceptor] Invalid role identifier: %s", role)  
                }  
             }  
          } else if strings.HasPrefix(role, "learner") {  
             //3 : LEARNER  
             roleType = LEARNER  
             idStr := strings.TrimPrefix(role, "learner")  
             if idStr == "" {  
                return nil, fmt.Errorf("[Config] [learner] Invalid identifier: %s", role)  
             } else {  
                identifier, err = strconv.Atoi(idStr)  
                if err != nil {  
                   return nil, fmt.Errorf("[Config] [learner] Invalid role identifier: %s", role)  
                }  
             }  
          } else {  
             return nil, fmt.Errorf("[Config] Unknown role type: %s", role)  
          }  
  
          // Add to Roles map  
          rolesMap[identifier] = MessageStatus{  
             RoleType:        roleType,  
             PrepareSent:     false,  
             PrepareReceived: false,  
             AcceptSent:      false,  
             AcceptReceived:  false,  
          }  
       }  
  
       //HOSTNAME -> IP  
       var ip string  
       for {  
          ip, err = getIP(hostname)  
          if err == nil {  
             break  
          }  
          time.Sleep(DNS_REQUEST_DELAY) // Retry after delay = Too fast? DNS WILL NOT RESPOND!  
       }  
       if err != nil {  
          //If failed  
          return nil, fmt.Errorf("[Config] could not resolve IP for host: %s", hostname)  
       }  
  
       port := DEFAULT_PORT //In case not working!  
       peer := &Peer{  
          PeerID:   rowNumber,  
          IP:       ip,  
          Port:     port,  
          Hostname: hostname,  
          IsSelf:   hostname == currentHostname,  
          Roles:    rolesMap,  
       }  
  
       peerMap.AddPeer(peer)  
       rowNumber++  
    }  
  
    if err := scanner.Err(); err != nil {  
       return nil, fmt.Errorf("[CONFIG] ERROR READING FILE!: %v", err)  
    }  
  
    log_message(VERBOSE_DEBUG, "[Config] Total [%d] Hosts loaded.\n", len(peerMap.Peers))  
    return peerMap, nil  
}  
  
func getIP(hostname string) (string, error) {  
  
    ip_list, err := net.LookupIP(hostname)  
    if err != nil || len(ip_list) == 0 {  
       return "", err  
    }  
    return ip_list[0].String(), nil // First IP Address  
} // Hostname -> IP https://pkg.go.dev/net#LookupIP  
  
func getSelfHostname() (string, error) {  
    hostname, err := os.Hostname()  
    //If Hostname is nout in the OS  
    if err != nil {  
       return "", err  
    }  
    return hostname, nil  
} // Get my hostname https://pkg.go.dev/os#Hostname  
func printHosts(peerMap *PeerMap) {  
    peerMap.Mutex.Lock()  
    defer peerMap.Mutex.Unlock()  
  
    log_message(VERBOSE_INFO, "%-6s %-12s %-8s %-10s %-15s %-10s\n", "SrcID", "IP", "Port", "Hostname", "IsSelf", "Roles")  
    for _, peer := range peerMap.Peers {  
       //Role -> String  
       //Temporary List       rolesStr := []string{}  
  
       for id, status := range peer.Roles {  
          roleName := ""  
          switch status.RoleType {  
          case PROPOSER:  
             roleName = fmt.Sprintf("proposer[%d]", id)  
          case ACCEPTOR:  
             roleName = fmt.Sprintf("acceptor[%d]", id)  
          case LEARNER:  
             roleName = fmt.Sprintf("learner[%d]", id)  
          }  
          rolesStr = append(rolesStr, roleName)  
       }  
  
       log_message(VERBOSE_INFO, "%-6d %-12s %-8d %-10s %-15t %-10s\n", peer.PeerID, peer.IP, peer.Port, peer.Hostname, peer.IsSelf, strings.Join(rolesStr, ", ")) // New Line!  
    }  
}  
  
func printSendReceive(msg Message, action string) {  
    if !submissionSurpress {  
       log_message(VERBOSE_SUBMISSION, "{\"peer_id\":%d, \"action\": \"%s\", \"message_type\":\"%s\",\"message_value\":\"%c\", \"proposal_num\":%s}\n",  
          msg.SrcID,  
          action,  
          msg.MessageType.String(),  
          msg.MessageValue,  
          msg.ProposalNumber)  
    }  
}  
  
/*  
TCP Communication Server/Client  
*/  
//Server  
func startTCPServer(peer *Peer, peerMap *PeerMap) {  
    //1. TCP Listener  
    listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", peer.IP, peer.Port))  
    if err != nil {  
       log_message(VERBOSE_ERROR, "startTCPServer() Error starting TCP server:", err)  
       return  
    }  
  
    //A. When function ends, listening closed  
    defer listener.Close()  
    log_message(VERBOSE_INFO, "startTCPServer() TCP server started %s:%d\n", peer.IP, peer.Port)  
  
    //Accept -> GoRoutine(THRD) will do following jobs  
    //For is While in GO    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log_message(VERBOSE_ERROR, "startTCPServer() ERROR accepting connection", err)  
          continue  
       }  
       /*  
          *  GO Routine             Not completely a Thread but works like thread (Asynchronous)       */       go handleTCPConnection(conn, peer, peerMap)  
    }  
}  
func handleTCPConnection(conn net.Conn, peer *Peer, peerMap *PeerMap) {  
    /*  
       DECODER (Deserialization)    */    defer conn.Close() //Auto close  
  
    // Process incoming messages    decoder := gob.NewDecoder(conn) //Structs -> BYTES (not string)  
    var msg Message  
    err := decoder.Decode(&msg)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "Error decoding message: %v\n", err)  
       return  
    }  
  
    // Handle the decoded message  
    log_message(VERBOSE_DEBUG, "Received message: %+v\n", msg)  
    handleMessage(msg, peer, peerMap)  
}  
func handleMessage(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       Classify and Toss the message into the each logic       Proposer          PREPARE_ACK          ACCEPT_ACK       Acceptor          PREPARE          ACCEPT    */    switch msg.MessageType {  
    /*  
       Proposer    */    case PREPARE_ACK:  
       printSendReceive(msg, "received")  
       handlePrepareACK(msg, peer, peerMap)  
    case ACCEPT_ACK:  
       printSendReceive(msg, "received")  
       handleAcceptACK(msg, peer, peerMap)  
    /*  
       Acceptor    */    case PREPARE:  
       printSendReceive(msg, "received")  
       handlePrepare(msg, peer, peerMap)  
    case ACCEPT:  
       printSendReceive(msg, "received")  
       handleAccept(msg, peer, peerMap)  
  
    default:  
       log_message(VERBOSE_ERROR, "(TCP_SERVER) handleMessage() UNKNOWN TYPE: [%v]\n", msg.MessageType)  
    }  
}  
  
/*  
    Proposer*/  
  
func handlePrepareACK(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       4) When responses received from majority:          If any accepted Values returned,          replace value with accepted Value for highest accepted Proposal  
       1. Receive       2. Record at ProposerTracker       3. Check if the response was received from the majority       4.1. If not go back to receive state       4.2. If received from the majority, Broadcast Accept(n, value) to all servers    */    //1. States Start    //printSendReceive(msg, "received")    aStart := time.Now()  
    proposerState := getProposerState(msg.SrcID)  
    if proposerState == nil || len(proposerStates) <= 0 {  
       log_message(VERBOSE_ERROR, "handlePrepareACK() proposerState Not found!\n")  
       return  
    }  
  
    //2. Mutex ON for the states  
    proposerState.Mutex.Lock()  
    defer proposerState.Mutex.Unlock()  
  
    //3.MSG -> Proposal Number struct  
    acceptedProposalNumber, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handlePrepareACK() Invalid Proposal Number Parsing failed: %v\n", err)  
       return  
    }  
  
    //4. Record at ProposerTracker  
    proposerState.PrepareResponses = &Proposal{  
       ProposalNumber: acceptedProposalNumber,  
       Value:          msg.MessageValue,  
    }  
  
    totalResponses := CountPrepareResponses(proposerStates) // Total Response to calculate the quorum  
    totalPeers := len(peerMap.Peers)                        // Total Peers to calculate the peers  
    log_message(VERBOSE_DEBUG, "handlePrepareACK() TotalReponse/Peers = [%d/%d]\n", totalResponses, totalPeers)  
  
    //5. Quorum check (N/2)+1 Equation  
    if totalResponses >= ((totalPeers / 2) + 1) {  
       log_message(VERBOSE_DEBUG, "Quorum Formed! Prepare REDY! [%d/%d]\n", totalResponses, totalPeers)  
       /*  
          FIND THE HIGHEST PROPOSAL NUMBER & VALUE  
          1. Peers already have accepted higher proposal will ignore PREPARE anyway       */       highestNumber := proposerState.ProposalNumber // ME  
       highestValue := proposerState.Value           // MY VALUE  
  
       log_message(VERBOSE_DEBUG, "(Me) Proposal: %d Value: %d\n", highestNumber, highestValue)  
  
       statesHighestProposalNumber := ProposalNumber{}  
       statesHighestValue := byte(0)  
       log_message(VERBOSE_DEBUG, "Original Highest Proposal: %d Highest Value: %d\n", statesHighestProposalNumber, statesHighestValue)  
  
       //Find the highest number proposal with value in states (smaller than me anyway)  
       for i, prop := range proposerStates {  
          /*  
             1. Proposal Not exist in any response                >Propose with proposing value and new proposal number             2. Proposal Exist in 1 response                >Propose with existing value and new proposal number             3. Same Proposal Exist in all response                >Same as case 2                   >Propose with existing value and new proposal number             4. Different Proposal Exist in all response                >Find the highest Proposal Number and use that value but sending in a new proposal number  
             1. Once hits quorum, check if there's any inconsistent value/proposal in the state structure             2.1    If there's inconsistency detected, exception             2.2 If 1 unique value/proposal number found in state structure, use that (Multi/Single)          */          log_message(VERBOSE_DEBUG, "[%d] Current Proposer State : %+v\n", i, prop.PrepareResponses)  
  
          //Original  
          //if prop.ProposalNumber.GreaterThan(highestNumber) {          // log_message(VERBOSE_ERROR, "handlePrepareACK() If %v > %v then minProposal = %v \n", highestNumber, peer.minProposal, highestNumber)          //          // //If the Proposal Number is bigger than previous highest one? Update.          // highestNumber = prop.PrepareResponses.ProposalNumber          // highestValue = prop.PrepareResponses.Value          //}  
          //2. Find the biggest Proposal Number          log_message(VERBOSE_DEBUG, "handlePrepareACK() shpn:[%s] PROP.PREPARE.PN:[%s] \n", statesHighestProposalNumber.String(), prop.PrepareResponses.ProposalNumber.String())  
          if prop.PrepareResponses.ProposalNumber.GreaterThan(statesHighestProposalNumber) {  
             log_message(VERBOSE_DEBUG, "handlePrepareACK() If %v > %v then minProposal = %v \n", prop.PrepareResponses.ProposalNumber.String(), statesHighestProposalNumber.String(), prop.PrepareResponses.ProposalNumber.String())  
  
             //If the Proposal Number is bigger than previous highest one? Update.  
             statesHighestProposalNumber = prop.PrepareResponses.ProposalNumber  
             statesHighestValue = prop.PrepareResponses.Value  
             log_message(VERBOSE_DEBUG, "statesHighestProposalNumber:[%+v],statesHighestValue:[%c]\n", statesHighestProposalNumber, statesHighestValue)  
          }  
  
       }  
       log_message(VERBOSE_DEBUG, "states) Highest Proposal: %d Highest Value: %d\n", statesHighestProposalNumber, statesHighestValue)  
  
       //Compare with my proposenumber and value  
       //IF statesHighestProposalNumber is higher than highestNumber = NO       //If statesHighestProposalNumber is lower AND highestValue is different = Use the highestValue but keep my pn       log_message(VERBOSE_DEBUG, "statesHighestProposalNumber: %v,highestNumber: %v, statesHighestValue: %v, highestValue: %v \n", statesHighestProposalNumber, highestNumber, statesHighestValue, highestValue)  
       if !statesHighestProposalNumber.GreaterThan(highestNumber) && statesHighestProposalNumber != highestNumber && statesHighestValue != highestValue && statesHighestValue != byte(0) {  
          log_message(VERBOSE_DEBUG, "handlePrepareACK() OK : PN RECV<ME, SHV != HV, SHV != 0\n")  
          highestValue = statesHighestValue  
          proposerState.Value = highestValue  
       } else if statesHighestProposalNumber.GreaterThan(highestNumber) {  
          log_message(VERBOSE_ERROR, "handlePrepareACK() Me[%s] Received[%s]\n", statesHighestProposalNumber.String(), highestNumber.String())  
       }  
  
       log_message(VERBOSE_DEBUG, "Updated Highest Proposal: %d Highest Value: %d\n", highestNumber, highestValue)  
  
       // 4.2. If received from the majority, Broadcast Accept(n, value) to all servers  
       sortedDestination := peerMap.GetAllPeersSorted()  
       for _, acceptor := range sortedDestination {  
          pRole := acceptor.Roles[ROLE_ORDER]  
          if acceptor.PeerID == peer.PeerID {  
             //log_message(VERBOSE_DEBUG, "Acceptr> Skip myself.\n")  
             continue  
          }  
          //Send ACCEPT message only to the Acceptors and Learners  
          if pRole.RoleType == ACCEPTOR {  
             //log_message(VERBOSE_DEBUG, "Acceptr-ACCEPTOR> Dest[%d], pRole[%+v]\n", acceptor.PeerID, pRole)  
  
          } else if pRole.RoleType == LEARNER {  
             //log_message(VERBOSE_DEBUG, "Acceptr-LEARNER> Dest[%d], pRole[%+v]\n", acceptor.PeerID, pRole)  
          } else {  
             //log_message(VERBOSE_DEBUG, "Acceptr> Dest[%d], pRole[%+v]\n", acceptor.PeerID, pRole)  
             //log_message(VERBOSE_DEBUG, "Acceptr> Destination NOT Acceptor or Learner. Skipping.\n")             continue  
          }  
  
          acceptMsg := Message{  
             SrcID:          peer.PeerID,  
             DestID:         acceptor.PeerID,  
             MessageType:    ACCEPT,  
             ProposalNumber: highestNumber.String(),  
             MessageValue:   highestValue,  
          }  
          //printSendReceive(acceptMsg, "sent")  
          log_message(VERBOSE_DEBUG, "handlePrepareACK() ACCEPT sending to %d.\n", acceptor.PeerID)  
          err := SendMessage(acceptMsg, peer, peerMap)  
          if err != nil {  
             log_message(VERBOSE_ERROR, "handlePrepareACK() Send ACCEPT Failed : %v\n", err)  
          }  
          log_message(VERBOSE_DEBUG, "handlePrepareACK() Wait %f Seconds\n", ACCEPTOR_SEND_INTERVAL)  
          time.Sleep(ACCEPTOR_SEND_INTERVAL)  
       }  
       aDuration := time.Since(aStart)  
       log_message(VERBOSE_DEBUG, "ACCEPTOR DONE IN %.6f seconds\n", aDuration.Seconds())  
    }  
}  
func handleAcceptACK(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       7) When responses received from majority:          Any rejections (result > n)?  goto (1)          Otherwise, value is chosen  
       1. Receive       2. Record       3. Check if the response was received from the majority       4. Check if the response has any rejection {Any rejections (result > n)?  goto (1)}       4.1. If not = VALUE IS CHOSEN!       4.2. If there's any rejection? Go back to the 1st Phase {Proposer: 1) Choose new proposal number n}    */  
    //1. get proposerState    //printSendReceive(msg, "received")    proposerState := getProposerState(msg.SrcID)  
    if proposerState == nil {  
       //Non acceptor is not counting towards quorum.  
       log_message(VERBOSE_DEBUG, "handleAcceptACK() can't find my state %d\n", msg.SrcID)  
       return  
    }  
  
    //2. proposerState MUTEX  
    proposerState.Mutex.Lock()  
    defer proposerState.Mutex.Unlock()  
  
    //3. MSG -> Proposal Number struct  
    proposalNum, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handleAcceptACK() ParseProposalNumber() error\n")  
    }  
    proposerState.AcceptResponses = &Proposal{  
       ProposalNumber: proposalNum,  
       Value:          msg.MessageValue,  
    }  
  
    totalResponses := CountAcceptResponses(proposerStates) // Total Response to calculate the quorum  
    totalPeers := len(peerMap.Peers)                       // Total Peers to calculate the peers  
    log_message(VERBOSE_DEBUG, "handleAcceptACK() TotalReponse/Peers = [%d/%d]\n", totalResponses, totalPeers)  
  
    //3. Check if the response was received from the majority  
    if totalResponses >= (totalPeers/2)+1 {  
       log_message(VERBOSE_DEBUG, "Quorum Formed! Accept REDY! [%d/%d]\n", totalResponses, totalPeers)  
       // Any rejections (result > n)?  goto (1)  
  
       // Otherwise, value is chosen       log_message(VERBOSE_INFO, "handleAcceptACK() Value '%c' was chosen with Proposal Number [%s]!\n", proposerState.Value, proposerState.ProposalNumber.String())  
       peer.acceptedValue = proposerState.Value  
       peer.acceptedProposal = proposerState.ProposalNumber  
       log_message(VERBOSE_SUBMISSION, "{\"peer_id\":%d "+  
          "\"action\": \"chose\",\"message_type\":\"chose\",\"message_value\":\"%c\","+  
          "\"proposal_num\":%s}\n",  
          peer.PeerID, peer.acceptedValue, peer.acceptedProposal.String())  
       //Reset Proposer Tracker  
       proposerStates = nil  
    }  
}  
  
/*  
Acceptor  
*/  
func handlePrepare(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       3) Respond to Prepare(n):          If n > minProposal then minProposal = n          Return(acceptedProposal, acceptedValue)  
       1. Check If received n is bigger than minProposal          then change minProposal value into received n       2. Respond server with acceptedProposal, acceptedValue message=    */    //1. MSG -> Proposal Number struct    //printSendReceive(msg, "received")  
    n, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handlePrepare() Invalid Proposal Number Parsing failed: %v\n", err)  
       return  
    }  
  
    //2. Peer MUTEX  
    peer.Mutex.Lock()  
    defer peer.Mutex.Unlock()  
  
    // 3. If n > minProposal then minProposal = n  
    if n.GreaterThan(peer.minProposal) {  
       log_message(VERBOSE_ERROR, "handlePrepare() If %v > %v then minProposal = %v \n", n, peer.minProposal, n)  
       //then minProposal = n  
       peer.minProposal = n  
       // 4. Message Creation  
       response := Message{  
          SrcID:          peer.PeerID,  
          DestID:         msg.SrcID,  
          MessageType:    PREPARE_ACK,  
          ProposalNumber: peer.acceptedProposal.String(), //Proposal -> String  
          MessageValue:   peer.acceptedValue,  
       }  
       // 5. Message Transmission  
       //printSendReceive(response, "sent")       err := SendMessage(response, peer, peerMap)  
       if err != nil {  
          log_message(VERBOSE_ERROR, "handlePrepare() Send failed : %v\n", err)  
       }  
  
    } else {  
       // 6. PREPARE message ignore  
       log_message(VERBOSE_DEBUG, "handlePrepare() PREPARE Ignored: n=%s (minProposal=%s)\n", n.String(), peer.minProposal.String())  
    }  
}  
func handleAccept(msg Message, peer *Peer, peerMap *PeerMap) {  
    /*  
       6. Respond to Accept(n, value):          If n ≥ minProposal then             acceptedProposal = minProposal = n             acceptedValue = value          Return(minProposal)  
       1.1If received n is bigger or same as  minProposal          2.1 then change acceptedProposal value into proposed proposal number n          2.2 change minProposal vlaue into proposed proposal number n          2.3 change acceptedValue as proposed value          3. Respond server with minProposal  
       1.2 If received n is NOT bigger or same as  minProposal          Ignore  
    */    //1. MSG -> Proposal Number struct    //printSendReceive(msg, "received")  
    n, err := ParseProposalNumber(msg.ProposalNumber)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "handleAccept() Invalid Proposal Number Parsing failed: %v\n", err)  
       return  
    }  
  
    //2. Peer MUTEX  
    peer.Mutex.Lock()  
    defer peer.Mutex.Unlock()  
  
    // 3. If n ≥ minProposal then  
    // acceptedProposal = minProposal = n    // acceptedValue = value    if n.GreaterThanOrEqual(peer.minProposal) {  
       rolesSorted := peer.GetSortedRoles()  
       if len(rolesSorted) <= 0 {  
          log_message(VERBOSE_ERROR, "RolesSorted Not Exist NO roles found\n")  
          return  
       }  
  
       log_message(VERBOSE_DEBUG, "handleAccept() n ≥ minProposal\n")  
       peer.minProposal = n                  // acceptedProposal = minProposal = n  
       peer.acceptedProposal = n             // acceptedProposal = minProposal = n  
       peer.acceptedValue = msg.MessageValue // acceptedValue = value  
       log_message(VERBOSE_DEBUG, "ACCEPTED!  acceptedProposal:%d,acceptedValue:%d\n", peer.acceptedProposal, peer.acceptedValue)  
  
       if rolesSorted[0].RoleType == LEARNER {  
          log_message(VERBOSE_ERROR, "I am the Learner! NO MESSAGE WILL BE SENT!\n")  
          return  
       }  
  
       // 4. Message Creation  
       response := Message{  
          SrcID:          peer.PeerID,  
          DestID:         msg.SrcID,  
          MessageType:    ACCEPT_ACK,  
          ProposalNumber: peer.minProposal.String(),  
       }  
  
       err := SendMessage(response, peer, peerMap)  
       if err != nil {  
          log_message(VERBOSE_ERROR, "handleAccept() Send failed : %v\n", err)  
       }  
    } else {  
       // 6. PREPARE message ignore  
       log_message(VERBOSE_DEBUG, "handleAccept() PREPARE Ignored: n=%s (minProposal=%s)\n", n.String(), peer.minProposal.String())  
    }  
}  
  
// Client  
func SendMessage(message Message, peer *Peer, peerMap *PeerMap) error {  
    /*  
       Message to extract DestID    */    //1. Dest Info Extraction    destPeer, _ := peerMap.GetPeer(message.DestID)  
    if destPeer == nil {  
       return fmt.Errorf("SendMessage() Peer Not Found")  
    }  
    destPeerID := destPeer.PeerID  
    destPeerIP := destPeer.IP  
    destPeerPort := destPeer.Port  
  
    //2.Connect  
    address := fmt.Sprintf("%s:%d", destPeerIP, destPeerPort)   // Make [IP]:[PORT]  
    conn, err := net.DialTimeout("tcp", address, 1*time.Second) // Time Out 1 SEC  
  
    if err != nil {  
       return err  
    }  
    defer conn.Close()  
  
    //3.Encode to bytes  
    encoder := gob.NewEncoder(conn)  
    if err := encoder.Encode(message); err != nil {  
       log_message(VERBOSE_ERROR, "Failed to send message to peer %d: %v\n", destPeerID, err)  
       return err  
    }  
    log_message(VERBOSE_DEBUG, "Sent message: %+v\n", message)  
    printSendReceive(message, "sent")  
    return nil  
}  
  
func runProposer(peer *Peer, peerMap *PeerMap, roundNumber int, value byte) {  
    /*  
       1. Choose new proposal number n (Use the one from the Peer.Roles int) ex:) 1 or 2       2. Creating a global ProposerTracker struct          1. Create a new ProposalNumber based on round number (roles.int) and serverID (my peer ID)          2. Add proposerID          3. Fill the ProposedValue from the CLI       2. Broadcast Prepare(n) to all servers          n = Proposal Number (RoundNumber.ServerID)    */    pStart := time.Now()  
    // 2. Broadcast Prepare(n) to all servers  
    sortedDestination := peerMap.GetAllPeersSorted()  
    for _, entity := range sortedDestination {  
       acceptor, res := peerMap.GetPeer(entity.PeerID)  
       if !res {  
          return  
       }  
       //Skip my self  
       if acceptor.PeerID == peer.PeerID {  
          continue  
       }  
       if entity.Roles[roundNumber].RoleType == ACCEPTOR {  
  
          //1. Choose new proposal number n (Use the one from the Peer.Roles int) ex:) 1 or 2  
          proposalNumber := ProposalNumber{  
             RoundNumber: roundNumber,  
             ServerID:    peer.PeerID,  
          }  
          //2. Creating a  Proposer State Tracker struct  
          proposerState := &ProposerState{  
             ProposalNumber:   proposalNumber,  
             Value:            value,  
             PrepareResponses: nil,  
             AcceptResponses:  nil,  
          }  
  
          storeProposerState(acceptor.PeerID, proposerState)  
          prepareMsg := Message{  
             SrcID:          peer.PeerID,  
             DestID:         acceptor.PeerID,  
             MessageType:    PREPARE,  
             ProposalNumber: proposalNumber.String(),  
          }  
          //printSendReceive(prepareMsg, "sent")  
          log_message(VERBOSE_DEBUG, "runProposer() PREPARE sending to %d.\n", entity.PeerID)  
          err := SendMessage(prepareMsg, peer, peerMap)  
          if err != nil {  
             log_message(VERBOSE_ERROR, "runProposer() PREPARE send failed: %v\n", err)  
          }  
          log_message(VERBOSE_DEBUG, "runProposer() Waiting for %f seconds\n", PROPOSER_SEND_INTERVAL)  
          time.Sleep(PROPOSER_SEND_INTERVAL)  
       }  
    }  
    pDuration := time.Since(pStart)  
    log_message(VERBOSE_DEBUG, "PROPOSER DONE IN %.6f seconds\n", pDuration.Seconds())  
}  
  
func main() {  
    START_TIME = time.Now()  
    var hostsFile string  
    var payloadValueTemp string  
  
    var delay float64  
  
    // Required  
    flag.StringVar(&hostsFile, "h", "", "REQUIRED! hostfile filename")  
    // Required If the peer is a proposer  
    flag.StringVar(&payloadValueTemp, "v", "X", "This is the value used if the peer is a proposer. It is a character.")  
    // Not required - TC2  
    flag.Float64Var(&delay, "t", -1, " This is the time in seconds proposer 2 will wait before starting its proposal with its value v. This will be needed for the second testcase scenario.")  
  
    flag.Parse()  
  
    var payloadValue byte = byte(payloadValueTemp[0])  
    if delay > 0 {  
       ROLE_ORDER = 2  
    }  
    /*  
       HOST INIT    */    // HostFile Load    if hostsFile == "" {  
       log_message(VERBOSE_ERROR, "NO HOSTSFILE PROVIDED. CHECK YOUR PARAMETER.")  
       return  
    }  
    peerMap, err := loadHosts(hostsFile)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "(main) HOSTFILE READER FAILED!: %v\n", err)  
       return  
    }  
    printHosts(peerMap)  
  
    // Self Detection  
    var selfPeer *Peer  
    selfPeer, _ = GetPeerSelf(peerMap)  
    if selfPeer == nil {  
       log_message(VERBOSE_ERROR, "(main) I can't find myself")  
       return  
    }  
  
    /*  
       SERVER INIT    */  
    go startTCPServer(selfPeer, peerMap)  
    log_message(VERBOSE_DEBUG, "main() SERVER STARTED!\n")  
    /*  
       CLIENT INIT    */    // Am I a Proposer? -> peers.roles    time.Sleep(2 * time.Second) // Delay  
    for _, status := range selfPeer.Roles {  
       if status.RoleType == PROPOSER {  
          log_message(VERBOSE_DEBUG, "main() I am the proposer!\n")  
          //Test case 2 (Wait)  
          if delay > 0 {  
             log_message(VERBOSE_DEBUG, "main() I am the proposer Test Case 2!\n")  
             time.Sleep(time.Duration(delay) * time.Second)  
          }  
          value := payloadValue  
          go runProposer(selfPeer, peerMap, 1, value)  
       }  
    }  
    select {}  
}
4. Here's my previous report
# REPORT  
## Junbeom In  
  
### Summary  
This program presents a Distributed Membership Protocol in Go. The application manages a dynamic group of peers, consistently handles membership views, ADD/DEL of peers, and peer failure detection, and manages leader election upon leader failures.  
  
## Overview  
The key functionalities include:  
- **Peer Addition and Deletion**: New peers can join the group, and existing peers can be removed through a protocol.  
- **Failure Detection**: A failure detector was built on UDP to ensure the liveness of each member's peers. The program also contains appropriate logic to handle peer failures.  
- **Leader Election**: When leader failure happens, a new leader is elected among the remaining peers based on peer IDs.  
- **Consistent Membership View**: A monotonically increasing ViewID was used to implement consistent membership. An updated MemberList will be created to reflect the current membership.  
  
## State Diagram  
### Proposer  
![Proposer](proposerStateDiagram.png)  
### Acceptor  
![Acceptor](acceptorStateDiagram.png)  
  
  
  
## Algorithm Details  
### 1.Initialization  
- **Host File Parsing**: Each peer reads a host file containing the list of peers. Each peer assigns IDs based on their row number in the file, which starts from 1.  
- **Peer Identification**: Peers determine if they are the leader (first in the list = row number 1).   
- **TCP and UDP Setup**: 2 connections, TCP and UDP, are set up to handle Message and Heartbeat Message. The UDP HB server starts after the membership is established.  
  
### 2. Message Types and Structures  
#### Message Types  
##### Normal  
```  
type Message struct {  
    MessageType MessageType //Enum    Operation   Operation    SrcID       int   //Destination Peer    DestID      int   //Source Peer    RequestID   int   //RequestID    ViewID      int   //Monotonically Increasing    LeaderID    int   //Not in use.    NewPeerID   int   //To be added/deleted    MemberList  []int //List includes members}  
```  
- **JOIN**: Peer sends leader a request to join the group.  
- **REQ**: Leader’s request to existing peers for adding or removing a peer.  
- **OK**: Existing Peers’ acknowledgment of the leader’s REQ request.  
- **NEWVIEW**: A leader confirms a new membership view.  
- **NEWLEADER**: The NewLeader message coordinates state reconciliation when an existing leader fails.  
  
##### Heartbeat  
```  
var heartbeatTimestamps = make(map[int]time.Time)  
var heartbeatMutex sync.Mutex  
  
type HeartbeatMessage struct {  
    ViewID int    SrcID  int    DestID int}  
```  
- **HEARTBEAT**: Sent periodically to other peers to detect failures.  
  
### 3. Peer Joining Protocol (Part 1)  
#### 3.1. Non-Leader Peer Actions  
- **JOIN Message**: A non-leader peer sends a JOIN message to the leader to initiate the joining process.  
- **Retry Mechanism**: If the leader is unreachable, the peer retries until the request is successful. (With timeout and max retries)  
#### 3.2. Actions  
- **Processing JOIN**: The leader handles JOIN messages and initiates the REQ-OK-NEWVIEW sequence.  
- **First Join Optimization**: If the leader receives the first JOIN request, the leader skips REQ-OK and adds a peer to the membership list.  
- **REQ Message**: The Leader sends  REQ messages with operation ADD to the existing peers.  
- **OK Message**: The peers reply with an OK message using a request received from the leader. And add the message to the Pending Queue.  
- **Collecting OKs**: The leader waits for OK messages from all alive peers.  
- **NEW VIEW**: Leader increments ViewID, updates MemberList, and sends NEWVIEW messages, including new peers, to confirm membership change.: Leader increments ViewID, updates MemberList, and sends NEWVIEW messages, including new peers, to confirm membership change.  
### 4. Failure Detection Mechanism (Part 2)  
- **Heartbeat Sending**: Once a peer is set up with a new membership, each peer sends heartbeat messages over UDP at predefined intervals.  
- **Heartbeat Monitoring**: Individual peers monitor incoming heartbeats to detect failures. Each peer uses ViewID,srcID, and destID to determine the eligibility for the heartbeat message. If the ViewID is old or the received heartbeat does not exist in the membership list, the peer ignores the heartbeat.  
- **Failure Detection**: If a peer misses heartbeats more than 2 times than the predefined detection threshold, it is considered failed.  
- **Failure Notification**: Peers print messages indicating detected failures.  
### 5. Peer Deletion Protocol (Part 3)  
- **Leader Initiation**: The leader and each peer detect a failed peer and start the deletion protocol. However, only the leaders perform actual ADD/DEL actions.  
- **REQ Message**: The Leader sends REQ messages with operation "DEL" with FailedPeerID to alive peers.  
- **Collecting OKs**: The leader waits for OK messages from all alive peers.  
- **Updating View**: Once the leader receives OKs from the entire peers, the leader increments ViewID, creates a new MemberList and sends NEWVIEW messages.  
### 6. Leader Failure and Election Handling (Part 4)  
- **Leader Failure Detection**: Each Peer detects leader failure through heartbeats.  
- **New Leader Election**: The peer with the lowest ID automatically becomes the new leader.  
- **Reconciliation Protocol**: New leader sends NEWLEADER messages to peers to reconcile state. Non-leader peers await the new leader to start the reconciliation process. The operation in this message is PENDING.  
- **Transmitting Pending Operations**: Every peer except the leader receives a NEWLEADER message and responds with another NEWLEADER message with the pending job, including ViewID, Operation, and TargetID. If there's nothing, the operation is NONE, and the other fields are blank.  
- **Completing Pending Operations**: The new leader compares its state with the received NEWLEADER response and completes pending operations based on peers' responses.  
### 7. Consistent Membership View  
- **ViewID Management**: The ViewID is incremented upon each membership change.  
- **Membership List**: Each peer maintains an updated Member List that mirrors the current membership.  
  
### Data Structures  
#### Peer  
```  
type Peer struct {  
    PeerID               int                       // PeerID - row number    IP                   string                    // IP address    TCPCommunicationPort int                       // Port Number    UDPHeartbeatPort     int                       // Port Number    Hostname             string                    // Hostname    IsLeader             bool                      // is Leader?    IsSelf               bool                      // is Self?    ViewID               int                       //Current View ID    LeaderID             int                       //Current Leader ID    MemberList           []int                     //Membership List    PendingOperations    []Message                 //Pending Jobs    Mutex                sync.Mutex                //Mutex    HeartbeatReceived    time.Time                 //Received Time    HeartbeatStarted     bool                      //isHeartBeatStarted    NewLeaderRequests    map[int]NewLeaderRequests //New Leader Request Tracker}  
```  
#### PeerList  
```  
type PeerList struct {  
    Peers []Peer    Mutex sync.Mutex}  
```  
#### ViewState and RequestState  
```  
type RequestState struct {  
    Type          MessageType    OperationType Operation    SrcID         int    DestID        int    TargetID      int    REQ           bool    OK            bool}  
type ViewState struct {  
    Requests map[int]*RequestState    ViewID   int}  
```  
The ViewState and Request state data structure tracks the REQ-OK sequence based on ViewID and RequestID.  
  
#### NewLeaderRequests  
```  
type NewLeaderRequests struct {  
    OutboundMessage Message    InboundMessage  Message    RequestID       int}  
```  
The NewLeaderRequests data structure tracks NEWLEADER req-res pair on Leader Peer.  
  
### Implementation Details  
#### Host File Parsing  
  
- File Reading: Peers read hostnames from the host file and convert it to an IP address.  
Peer Initialization: Create Peer structs with appropriate ID numbers based on Row numbers.  
- Self and Leader Identification: Determine which ID number the peer belongs to and the leader flag.  
  
#### TCP Communication  
- Server Setup: Start a TCP server to receive communication messages.  
- Connection Handling: Accept and handle incoming TCP connections based on the message type.  
- Message Decoding: Message serialization/deserialization directly in bytes. Strings are not used to serialize/deserialize the message.  
- Message Handling: Messages to appropriate handlers based on MessageType.  
  
#### UDP Heartbeat Mechanism  
- Heartbeat Sending: Send HeartbeatMessage to all peers at pre-defined intervals.  
- Heartbeat Receiving: Listen on the UDP port for heartbeats.  
- Failure Detection: Update heartbeat timestamps (Using a map) and detect missing heartbeats  
$$ current_time - timestamp time > 2 * t $$  
  
#### Message Handling Functions  
##### handleJoin  
- Leader Only: Processes JOIN messages if the peer is the leader.  
- Concurrency Control: Ensures only one JOIN is being processed at a time. (Or drop the connection)  
  
#### handleReq  
Peers save the message in the pending operation list and respond with OK.  
#### handleOk  
The leader collects OK messages and updates the membership once all the expected OK messages arrive.  
#### handleNewView  
The leader confirms the membership update. Each peer updates ViewID and MemberList upon receiving a NEW VIEW. And delete the pending job.  
### handleNewLeader  
- The new leader starts a state reconciliation using NEWLEADER messages  
- Once the leader receives all new leader responses from individual peers, it completes pending operations based on peers’ responses.  
  
### Output Messages  
#### Membership Updates  
```  
{peer_id:%d, view_id: %d, leader: %d, memb_list: [%s]}  
```  
#### Failure Detection  
##### Peer Crashing  
```  
"{peer_id:%d, view_id: %d, leader: %d, message:\"crashing\"}"  
```  
#### Peer Unreachable  
```  
{peer_id:%d, view_id: %d, leader: %d, message:\"peer %d unreachable\"}\  
```  
#### Leader Unreachable  
```  
{peer_id:%d, view_id: %d, leader: %d, message:"peer %d (leader) unreachable"}  
```
Could you give me a draft on a new instructions and codes?