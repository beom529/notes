### **1. 1단계: 멤버십 리스트에 새로운 피어 추가 (30점)**

- **초기화**:
    
    - 모든 피어는 구성 파일에서 가능한 모든 피어의 리스트를 읽습니다.
    - 파일에 나열된 순서에 따라 피어 ID를 할당하고, 첫 번째 피어가 리더가 됩니다.
    - 각 피어는 `view_id` (단조 증가하는 값)와 멤버십 리스트를 유지합니다.
- **JOIN 프로토콜**:
    
    - 새 피어가 시작되면 리더에게 `JOIN` 메시지를 보냅니다.
    - 리더는 다음과 같은 절차로 기존 멤버들과 프로토콜을 시작합니다:
        - 리더는 요청 ID, 현재 `view_id`, 작업 유형(ADD), 그리고 추가할 피어의 ID가 포함된 `REQ` 메시지를 멤버십 리스트의 모든 다른 피어에게 보냅니다.
        - 각 피어는 요청 ID, 현재 `view_id`, 작업 유형, 피어 ID를 저장하고, 요청 ID와 현재 `view_id`를 포함한 `OK` 메시지를 리더에게 보냅니다.
        - 리더는 모든 피어로부터 일치하는 `OK` 메시지를 받으면 `view_id`를 증가시키고, 새 피어를 멤버십 리스트에 추가한 뒤, 새로운 `view_id`와 업데이트된 멤버십 리스트가 포함된 `NEWVIEW` 메시지를 모든 피어에게 보냅니다.
        - 모든 피어는 `NEWVIEW` 메시지를 받으면 `view_id`와 멤버십 리스트를 업데이트하고 출력합니다.
- **최적화 가능**:
    
    - 리더는 전체 리스트를 새 피어에게만 보내고, 다른 피어에게는 새로운 `view_id`만 보낼 수 있습니다.
    - 통신은 TCP 또는 UDP로 구현할 수 있습니다. UDP를 사용하는 경우 신뢰할 수 있는 채널을 구현해야 합니다.
- **TESTCASE 1**: 모든 피어가 하나씩 차례대로 합류합니다. 리더가 먼저 시작합니다. 모든 피어가 합류할 때마다 멤버십 리스트와 `view_id`가 어떻게 변화했는지 각 피어에서 출력해야 합니다.
    
    - **출력 형식**:
        
        php
        
        Copy code
        
        `{peer_id:<ID>, view_id:<VIEW_ID>, leader:<LEADER_ID>, memb_list:[<MEMBERS>]}`
        

### **2. 2단계: 장애 감지기 구현 (10점)**

- **HEARTBEAT 메시지**:
    - 각 피어는 타임아웃 T가 만료될 때마다 `HEARTBEAT` 메시지를 브로드캐스트합니다.
    - 피어 P가 피어 Q로부터 두 번의 연속된 HEARTBEAT 메시지를 받지 못하면 Q가 실패했다고 선언하고, 아래 출력 형식에 맞게 출력합니다.
- **TESTCASE 2**: 피어 하나를 충돌시킨 후 나머지 피어들이 그 피어의 실패를 감지합니다.
    - **충돌하는 피어의 출력**:
        
        php
        
        Copy code
        
        `{peer_id:<ID>, view_id:<VIEW_ID>, leader:<LEADER_ID>, message:"crashing"}`
        
    - **나머지 피어의 출력**:
        
        php
        
        Copy code
        
        `{peer_id:<ID>, view_id:<VIEW_ID>, leader:<LEADER_ID>, message:"peer <PEER_ID> unreachable"}`
        
    - **리더가 충돌한 경우 출력**:
        
        php
        
        Copy code
        
        `{peer_id:<ID>, view_id:<VIEW_ID>, leader:<LEADER_ID>, message:"peer <PEER_ID> (leader) unreachable"}`
        

### **3. 3단계: 멤버십 리스트에서 피어 삭제 (20점)**

- 리더가 충돌을 감지한 후, 피어를 리스트에서 삭제하는 프로토콜을 시작합니다.
    
    - 리더는 요청 ID, 현재 `view_id`, 작업 유형(DEL), 삭제할 피어의 ID가 포함된 `REQ` 메시지를 모든 피어에게 보냅니다.
    - 각 피어는 `REQ` 메시지 정보를 저장하고 `OK` 메시지를 보냅니다.
    - 리더는 모든 피어로부터 일치하는 `OK` 메시지를 받으면 `view_id`를 증가시키고, 멤버십 리스트를 업데이트한 후, `NEWVIEW` 메시지를 보냅니다.
    - 각 피어는 `NEWVIEW` 메시지를 받으면 멤버십 리스트를 업데이트하고 출력합니다.
- **TESTCASE 3**: 모든 피어가 멤버십에 합류한 후, 피어를 하나씩 차례대로 충돌시킵니다. 리더가 남을 때까지 계속합니다.
    
    - **출력 형식**:
        
        php
        
        Copy code
        
        `{peer_id:<ID>, view_id:<VIEW_ID>, leader:<LEADER_ID>, memb_list:[<MEMBERS>]}`
        

### **4. 4단계: 리더 충돌 처리 (30점)**

- 리더가 충돌하면 가장 낮은 ID를 가진 피어가 새로운 리더가 됩니다.
    
- 새로운 리더는 `NEWLEADER` 메시지를 보내서 피어들에게 남아있는 처리되지 않은 작업이 있는지 확인합니다.
    
- 각 피어는 처리되지 않은 작업이 있으면 그 내용을 새로운 리더에게 보냅니다.
    
- 새로운 리더는 이전 리더의 작업을 마치고, 멤버십 리스트를 업데이트한 후, `NEWVIEW` 메시지를 보냅니다.
    
- **TESTCASE 4**: 리더가 피어를 삭제하는 요청을 보낸 후 충돌합니다. 새로운 리더가 요청을 이어받아 작업을 완료하고, 모든 피어들이 올바르게 업데이트됩니다.
    

이 단계를 기반으로 구현을 진행하면 됩니다.