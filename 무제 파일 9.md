package main  
  
import (  
    "bufio"  
    "encoding/json"    "flag"    "fmt"    "log"    "net"    "net/http"    _ "net/http/pprof"  
    "os"    "strings"    "sync"    "time")  
  
// Global Variables  
// https://pkg.go.dev/time#Duration  
var (  
    DEFAULT_COMMUNICATION_PORT int           = 3000  
    DEFAULT_HEARTBEAT_PORT     int           = 5000  
    START_DELAY                time.Duration = 1 * time.Second  
    JOIN_DELAY                 time.Duration = 0 * time.Second  
    HEARTBEAT_INTERVAL         time.Duration = 2 * time.Second  
    DNS_REQUEST_DELAY          time.Duration = 1500 * time.Millisecond  
)  
  
// Message Structtype MessageType int  
  
const (  
    JOIN MessageType = iota // 0  
    REQ  
    OK        // 1  
    NEWVIEW   // 2  
    NEWLEADER // 3  
)  
  
// Operation Structtype Operation int  
  
const (  
    NONE Operation = iota  
    ADD  
    DEL    PENDING)  
  
// Message (Payload) Structtype Message struct {  
    MessageType MessageType //Enum  
    Operation   Operation  
    SrcID       int //Destination Peer  
    DestID      int  
    RequestID   int  
    ViewID      int //Monotonically Increasing  
    LeaderID    int  
    NewPeerID   int  
    MemberList  []int //List includes members  
}  
  
// HB Message Structtype HeartbeatMessage struct {  
    ViewID int  
    SrcID  int  
    DestID int  
}  
  
var heartbeatTimestamps = make(map[int]time.Time)  
var heartbeatMutex sync.Mutex  
  
// Message State Management  
  
//nodeID is the Key  
/*  
ViewID1 : RequestID :{Req TF, OK TF}*/  
type RequestState struct {  
    SrcID  int  
    DestID int  
    REQ    bool  
    OK     bool  
}  
type ViewState struct {  
    Requests map[int]*RequestState  
    ViewID   int  
}  
  
var viewStates = make(map[int]*ViewState)  
  
// ADD  
func (viewstates *ViewState) ADD(requestID, srcID, destID int, req, ok bool) {  
    if viewstates.Requests == nil {  
       viewstates.Requests = make(map[int]*RequestState)  
    }  
    viewstates.Requests[requestID] = &RequestState{SrcID: srcID, DestID: destID, REQ: req, OK: ok}  
}  
  
// Detete  
func (viewstates *ViewState) REMOVE(requestID int) {  
    delete(viewstates.Requests, requestID)  
}  
  
// Search by RequestID (ViewID NOT)func (viewstates *ViewState) SEARCH(requestID int) (*RequestState, bool) {  
    request, exists := viewstates.Requests[requestID]  
    return request, exists  
}  
  
// Length  
func (viewstates *ViewState) LENGTH() int {  
    return len(viewstates.Requests)  
}  
  
// Update  
func (viewstates *ViewState) UPDATE(requestID int, req bool, ok bool) bool {  
    requestState, exists := viewstates.Requests[requestID]  
    if !exists {  
       log_message(VERBOSE_ERROR, "Viewstates Update Failed\n")  
       return false  
    }  
    requestState.REQ = req  
    requestState.OK = ok  
    log_message(VERBOSE_DEBUG, "Viewstates RequestID[%d] Update now.\n", requestID)  
    return true  
}  
  
// Peer Struct// In go struct member name has to start with capital letter  
// Structs : https://go.dev/tour/moretypes/2  
// Mutex : https://go.dev/tour/concurrency/9type Peer struct {  
    PeerID               int        // PeerID - row number    IP                   string     // IP address    TCPCommunicationPort int        // Port Number  
    UDPHeartbeatPort     int        // Port Number  
    Hostname             string     // Hostname  
    IsLeader             bool       // is Leader?  
    IsSelf               bool       // is Self?  
    ViewID               int        //Current View ID  
    LeaderID             int        //Current Leader ID  
    MemberList           []int      //Membership List  
    PendingOperations    []Message  //Pending Jobs  
    Mutex                sync.Mutex //Mutex  
    HeartbeatReceived    time.Time  //Received Time  
    HeartbeatStarted     bool       //isHeartBeatStarted  
}  
type PeerList struct {  
    //List  
    Peers []Peer  
    Mutex sync.Mutex  
}  
  
func GetPeerByID(peerList *PeerList, id int) (*Peer, error) {  
    peerList.Mutex.Lock()  
    defer peerList.Mutex.Unlock()  
  
    for _, peer := range peerList.Peers {  
       if peer.PeerID == id {  
          return &peer, nil  
       }  
    }  
    return nil, fmt.Errorf("GetPeerByID() peer not found! \n")  
}  
func GetPeerSelf(peerList *PeerList) (*Peer, error) {  
    peerList.Mutex.Lock()  
    defer peerList.Mutex.Unlock()  
  
    for _, peer := range peerList.Peers {  
       if peer.IsSelf {  
          return &peer, nil  
       }  
    }  
    return nil, fmt.Errorf("Where am I? \n")  
}  
func GetPeerLeader(peerList *PeerList) (*Peer, error) {  
    peerList.Mutex.Lock()  
    defer peerList.Mutex.Unlock()  
  
    for _, peer := range peerList.Peers {  
       if peer.IsLeader {  
          return &peer, nil  
       }  
    }  
    return nil, fmt.Errorf("Can't find the lead \n")  
}  
  
// File -> PeerList  
// File -> Line -> Peer -> Crating a Peerlist// Error Handling : https://pkg.go.dev/fmt  
// Methods https://go.dev/tour/methods/1  
// Declaration : https://go.dev/blog/declaration-syntax  
// nil : https://go101.org/article/nil.html  
func loadHosts(filename string) (*PeerList, error) {  
    log_message(VERBOSE_DEBUG, "1. [CONFIG] READING A HOSTFILE\n")  
  
    file, err := os.Open(filename)  
    if err != nil {  
       return nil, fmt.Errorf("no file detected: %v", err)  
    }  
    defer file.Close()  
  
    hosts := &PeerList{}  
    scanner := bufio.NewScanner(file)  
    rowNumber := 1  
  
    currentHostname, err := getSelfHostname()  
    if err != nil {  
       return nil, fmt.Errorf("[CONFIG] could not get current hostname: %v", err)  
    }  
  
    for scanner.Scan() {  
       line := strings.TrimSpace(scanner.Text())  
       if line == "" {  
          continue  
       }  
  
       hostname := line  
       if hostname != "" {  
          var ip string  
          var err error  
  
          for {  
             ip, err = getIP(hostname)  
             if err == nil {  
                break  
             }  
             time.Sleep(DNS_REQUEST_DELAY)  
          }  
          if err != nil {  
             return nil, fmt.Errorf("[Config] could not resolve IP for host: %s", hostname)  
          }  
  
          peer := Peer{  
             PeerID:               rowNumber,  
             IP:                   ip,  
             TCPCommunicationPort: DEFAULT_COMMUNICATION_PORT,  
             UDPHeartbeatPort:     DEFAULT_HEARTBEAT_PORT,  
             Hostname:             hostname,  
             IsLeader:             rowNumber == 1, //Only first one  
             IsSelf:               hostname == currentHostname,  
             HeartbeatStarted:     false,  
          }  
  
          // Leader = start with inclusion  
          // Peer = NEWVIEW will handle this          if peer.IsLeader && hostname == currentHostname {  
             peer.MemberList = []int{peer.PeerID}  
          } else {  
             peer.MemberList = []int{}  
          }  
  
          hosts.Peers = append(hosts.Peers, peer)  
          rowNumber++  
       } else {  
          log_message(VERBOSE_ERROR, "[Config] no hostname provided")  
          return nil, fmt.Errorf("[Config] no hostname provided")  
       }  
    }  
  
    log_message(VERBOSE_DEBUG, "[Config] Total [%d] Hosts loaded.\n", len(hosts.Peers))  
    return hosts, nil  
}  
func printHosts(peerList *PeerList) {  
    peerList.Mutex.Lock()  
    defer peerList.Mutex.Unlock()  
  
    log_message(VERBOSE_INFO, "%-6s %-12s %-8s %-8s %-15s %-10s %-10s %-6s %-6s %-18s %-18s\n",  
       "SrcID", "IP", "TCP Port", "UDP Port", "Hostname", "IsLeader", "IsSelf", "ViewID", "LeaderID", "MemberList", "PendingOperation")  
    for _, peer := range peerList.Peers {  
       log_message(VERBOSE_INFO, "%-6d %-12s %-8d %-8d %-15s %-10t %-10t %-6d %-6d %-18v %-18v\n",  
          peer.PeerID, peer.IP, peer.TCPCommunicationPort, peer.UDPHeartbeatPort, peer.Hostname, peer.IsLeader, peer.IsSelf, peer.ViewID, peer.LeaderID, peer.MemberList, peer.PendingOperations)  
    }  
}  
func getIP(hostname string) (string, error) {  
    ip_list, err := net.LookupIP(hostname)  
    if err != nil || len(ip_list) == 0 {  
       return "", err  
    }  
    return ip_list[0].String(), nil // First IP Address  
} // Hostname -> IP https://pkg.go.dev/net#LookupIP  
func getSelfHostname() (string, error) {  
    hostname, err := os.Hostname()  
    //If Hostname is nout in the OS  
    if err != nil {  
       return "", err  
    }  
    return hostname, nil  
} // Get my hostname https://pkg.go.dev/os#Hostname  
  
// Logger  
// type VerboseLevel int  
// https://blog.learngoprogramming.com/golang-variadic-funcs-how-to-patterns-369408f19085  
const (  
    VERBOSE_SUBMISSION = iota  
    VERBOSE_ERROR  
    VERBOSE_WARNING    VERBOSE_INFO    VERBOSE_DEBUG)  
  
var currentVerboseLevel = VERBOSE_DEBUG  
  
func log_message(verboseLevel int, format string, args ...interface{}) {  
    if verboseLevel <= currentVerboseLevel {  
       // stderr  
       fmt.Fprintf(os.Stderr, format, args...)  
    }  
}  
  
/*  
TCP Communication Server/Client  
Learned from : https://medium.com/@viktordev/socket-programming-in-go-write-a-simple-tcp-client-server-c9609edf3671  
TCP Server -> Connection Handling -> Message Classification -> Message Handling*/  
func startTCPServer(peer *Peer, peerList *PeerList) {  
    //1. TCP Listener  
    listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", peer.IP, peer.TCPCommunicationPort))  
    if err != nil {  
       log_message(VERBOSE_ERROR, "startTCPServer() Error starting TCP server:", err)  
       return  
    }  
    //A. When function ends, listening closed  
    defer listener.Close()  
    log_message(VERBOSE_INFO, "startTCPServer() TCP server started %s:%d\n", peer.IP, peer.TCPCommunicationPort)  
  
    //Accept -> GoRoutine(THRD) will do following jobs  
    //For is While in GO    for {  
       conn, err := listener.Accept()  
       if err != nil {  
          log_message(VERBOSE_ERROR, "startTCPServer() ERROR accepting connection", err)  
          continue  
       }  
       /*  
          *  GO Routine             Not completely a Thread but works like thread (Asynchronous)       */       go handleTCPConnection(conn, peer, peerList)  
    }  
}  
func handleTCPConnection(conn net.Conn, peer *Peer, peerList *PeerList) {  
    /*  
       DECODER (Deserialization)    */    defer conn.Close()  
  
    // Process incoming messages  
    decoder := json.NewDecoder(conn)  
    var msg Message  
    err := decoder.Decode(&msg)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "Error decoding message: %v\n", err)  
       return  
    }  
    if msg.MessageType == JOIN && isProcessingJoin {  
       log_message(VERBOSE_ERROR, "handleconnection() JOIN IN PROGRESS %v\n", err)  
       conn.Close()  
    }  
    // Handle the decoded message  
    log_message(VERBOSE_DEBUG, "Received message: %+v\n", msg)  
    handleMessage(msg, peer, peerList)  
}  
func handleMessage(msg Message, peer *Peer, peerList *PeerList) {  
    /*  
       Classify and Toss the message into the each logic    */    switch msg.MessageType {  
    //LEADER  
    //PART1    case JOIN:  
       handleJoin(msg, peer, peerList)  
    case REQ:  
       handleReq(msg, peer, peerList)  
    case OK:  
       handleOk(msg, peer, peerList)  
    case NEWVIEW:  
       handleNewView(msg, peer, peerList)  
       //PART 4  
    case NEWLEADER:  
       handleNewLeader(msg, peer, peerList)  
    default:  
       log_message(VERBOSE_ERROR, "(TCP_SERVER) handleMessage() UNKNOWN TYPE: [%v]\n", msg.MessageType)  
    }  
}  
  
func sendNewView(peer *Peer, peerList *PeerList, newViewDestMembers []int) Message {  
  
    //dest = for  
    newViewMsg := Message{  
       MessageType: NEWVIEW,  
       SrcID:       peer.PeerID,  
       ViewID:      peer.ViewID,  
       LeaderID:    peer.PeerID,  
       MemberList:  peer.MemberList,  
    }  
  
    // send NEWVIEW to every designated ids  
    for _, memberID := range newViewDestMembers {  
       if memberID == peer.PeerID {  
          continue  
       }  
       newViewMsg.DestID = memberID  
       if err := sendMessageToPeer(newViewMsg, memberID, peerList); err != nil {  
          log_message(VERBOSE_ERROR, "Failed to send NEWVIEW to [%d]: %+v\n", memberID, err)  
       }  
    }  
  
    log_message(VERBOSE_DEBUG, "sendNewView() Sent NEWVIEW to specified members\n")  
  
    return newViewMsg  
}  
func sendReqToMembers(selfPeer *Peer, peerList *PeerList) {  
    /*  
       1. 1 ViewID       2. Multiple RequestID by src/dest       3.    */    log_message(VERBOSE_DEBUG, "sendReqToMembers() STARTING\n")  
    viewID := selfPeer.ViewID  
    currentMembers := make([]int, len(selfPeer.MemberList))  
    copy(currentMembers, selfPeer.MemberList)  
  
    /*  
       If view ID is not there, init    */    if _, exists := viewStates[viewID]; !exists {  
       viewStates[viewID] = &ViewState{  
          Requests: make(map[int]*RequestState),  
          ViewID:   viewID,  
       }  
    }  
  
    // REQ MSG Creation  
    reqMsg := Message{  
       MessageType: REQ,  
       Operation:   ADD,  
       ViewID:      viewID,  
       SrcID:       selfPeer.PeerID,  
       LeaderID:    selfPeer.PeerID,  
       NewPeerID:   currentProcessingID,  
    }  
  
    var wg sync.WaitGroup  
    for _, memberID := range currentMembers {  
       log_message(VERBOSE_DEBUG, "CURRENT TURN TO SEND REQ : [%d]\n", memberID)  
       if memberID == selfPeer.PeerID {  
          log_message(VERBOSE_DEBUG, "SELF DETECTED. SKIPPING.\n")  
          continue  
       }  
       //Request ID Issue  
       requestID := int(time.Now().UnixNano())  
       viewStates[viewID].ADD(requestID, selfPeer.PeerID, memberID, true, false)  
  
       reqMsgCopy := reqMsg  
       reqMsgCopy.RequestID = requestID  
       reqMsgCopy.DestID = memberID  
       wg.Add(1)  
       go func(memberID int, reqMsg Message) {  
          defer wg.Done()  
          log_message(VERBOSE_DEBUG, "sendReqToMembers() SENDING REQ [%v]\n", reqMsg)  
          if err := sendMessageToPeer(reqMsg, memberID, peerList); err != nil {  
             log_message(VERBOSE_ERROR, "Failed to send REQ to [%d]: %v\n", memberID, err)  
          }  
       }(memberID, reqMsgCopy)  
    }  
    wg.Wait()  
}  
  
var isProcessingJoin = false  
var currentProcessingID = 0  
  
func handleJoin(msg Message, selfPeer *Peer, peerList *PeerList) {  
    // 1. Check Leader  
    if !selfPeer.IsLeader {  
       log_message(VERBOSE_ERROR, "handleJoin() Peer is not leader.\n")  
       os.Exit(1)  
    }  
  
    // 2.Concurrent check and block  
    if isProcessingJoin {  
       log_message(VERBOSE_ERROR, "handleJoin() Already processing another JOIN request.\n")  
       return  
    }  
    isProcessingJoin = true  
    //defer func() { isProcessingJoin = false }()  
  
    log_message(VERBOSE_DEBUG, "handleJoin() RECEIVED JOIN FROM [%d]\n", msg.SrcID)  
  
    // 3. First Message  
    // Skip REQ-OK    if len(selfPeer.MemberList) == 1 && selfPeer.MemberList[0] == selfPeer.PeerID {  
       log_message(VERBOSE_DEBUG, "handleJoin() First JOIN message, SKIPPING REQ message.\n")  
  
       selfPeer.Mutex.Lock()  
       selfPeer.ViewID++  
       selfPeer.MemberList = append(selfPeer.MemberList, msg.SrcID)  
       selfPeer.Mutex.Unlock()  
  
       // New member send newview  
       newViewMsg := sendNewView(selfPeer, peerList, []int{msg.SrcID})  
  
       //Me too  
       selfPeer.Mutex.Lock()  
       if newViewMsg.MemberList != nil {  
          selfPeer.MemberList = newViewMsg.MemberList  
       }  
       selfPeer.ViewID = newViewMsg.ViewID  
       selfPeer.LeaderID = newViewMsg.LeaderID  
       selfPeer.Mutex.Unlock()  
  
       printMembership(selfPeer, peerList)  
       //log_message(VERBOSE_DEBUG, "handleJoin() Updated self after processing NEWVIEW\n")  
       isProcessingJoin = false  
       return  
    }  
  
    // 3. Not the first JOIN  
    // REQ send    currentProcessingID = msg.SrcID  
    sendReqToMembers(selfPeer, peerList)  
}  
func handleOk(msg Message, peer *Peer, peerList *PeerList) {  
    if !peer.IsLeader {  
       log_message(VERBOSE_ERROR, "handleOk() I am not a Leader! Ignore the message.\n")  
       os.Exit(1)  
    }  
  
    log_message(VERBOSE_DEBUG, "handleOk() Received OK from %d. REQ ID: %d, VIEW ID: %d\n", msg.SrcID, msg.RequestID, msg.ViewID)  
  
    // ViewState Search (ViewID,RequestID)  
    viewState, exists := viewStates[msg.ViewID]  
    if !exists {  
       log_message(VERBOSE_WARNING, "handleOk() No matching ViewID: %d\n", msg.ViewID)  
       return  
    }  
  
    // ViewState.RequestID Search  
    requestState, reqExists := viewState.SEARCH(msg.RequestID)  
    if !reqExists {  
       log_message(VERBOSE_WARNING, "handleOk() No matching RequestID: %d for ViewID: %d\n", msg.RequestID, msg.ViewID)  
       return  
    }  
  
    // If not OK yet  
    if msg.SrcID == requestState.DestID && !requestState.OK {  
       if !viewState.UPDATE(msg.RequestID, requestState.REQ, true) {  
          log_message(VERBOSE_WARNING, "handleOk() Failed to update RequestID: %d\n", msg.RequestID)  
          return  
       }  
    }  
  
    // 모든 OK 메시지가 수신되었는지 확인  
    allOkReceived := true  
    for _, req := range viewState.Requests {  
       if !req.OK {  
          allOkReceived = false  
          break  
       }  
    }  
  
    // 모든 OK 메시지가 수신되었으면 NEWVIEW 메시지 전송  
    if allOkReceived {  
       log_message(VERBOSE_DEBUG, "handleOk() All OK messages received for ViewID: %d. Sending NEWVIEW.\n", msg.ViewID)  
  
       peer.Mutex.Lock()  
       peer.ViewID++  
  
       // Operation에 따라 멤버십 리스트 업데이트  
       operation := requestState.REQ // ADD 또는 DEL       if operation {  
          // ADD  
          peer.MemberList = append(peer.MemberList, currentProcessingID)  
       } else {  
          // DEL  
          newMemberList := []int{}  
          for _, id := range peer.MemberList {  
             if id != currentProcessingID {  
                newMemberList = append(newMemberList, id)  
             }  
          }  
          peer.MemberList = newMemberList  
       }  
       peer.Mutex.Unlock()  
  
       sendNewView(peer, peerList, peer.MemberList)  
  
       // ViewState 정리  
       delete(viewState.Requests, msg.RequestID)  
       if len(viewState.Requests) == 0 {  
          delete(viewStates, msg.ViewID)  
       }  
       printMembership(peer, peerList)  
       isProcessingJoin = false  
    } else {  
       log_message(VERBOSE_DEBUG, "handleOk() Waiting for more OK messages for ViewID: %d\n", msg.ViewID)  
    }  
}  
  
// PEER  
func handleReq(msg Message, peer *Peer, peerList *PeerList) {  
    log_message(VERBOSE_DEBUG, "handleReq() REQ from [%d]\n", msg.SrcID)  
  
    // 지원되는 Operation인지 확인  
    if msg.Operation != ADD && msg.Operation != DEL {  
       log_message(VERBOSE_WARNING, "handleReq() NOT SUPPORTED OPERATION: %v\n", msg.Operation)  
       return  
    }  
  
    peer.Mutex.Lock()  
    defer peer.Mutex.Unlock()  
  
    // Operation에 따라 다른 처리  
    if msg.Operation == ADD {  
       // ADD 오퍼레이션인 경우  
       log_message(VERBOSE_DEBUG, "handleReq() ADD operation pending\n")  
       peer.PendingOperations = append(peer.PendingOperations, msg)  
    } else if msg.Operation == DEL {  
       // DEL 오퍼레이션인 경우  
       log_message(VERBOSE_DEBUG, "handleReq() DEL operation pending\n")  
       peer.PendingOperations = append(peer.PendingOperations, msg)  
    }  
  
    // OK 메시지 생성 및 전송  
    log_message(VERBOSE_DEBUG, "handleReq() REQ - OK MSG creating\n")  
  
    okMsg := Message{  
       MessageType: OK,  
       RequestID:   msg.RequestID,  
       ViewID:      msg.ViewID,  
       SrcID:       peer.PeerID,  
       DestID:      msg.SrcID,  
    }  
  
    log_message(VERBOSE_DEBUG, "handleReq() REQ - OK MSG sending\n")  
  
    if err := sendMessageToPeer(okMsg, okMsg.DestID, peerList); err != nil {  
       log_message(VERBOSE_ERROR, "handleReq() Failed to send OK to leader [%d]: %v\n", msg.LeaderID, err)  
    }  
}  
func handleNewView(msg Message, peerSelf *Peer, peerList *PeerList) {  
    /*  
  
       [Client]       1. Received NEWVIEW       2. Change the current ViewID and membership list  
       [Instruction]       When receiving the NEWVIEW message all processes update their view id       and membership list and print the new view (view id and membership list).  
    */    log_message(VERBOSE_DEBUG, "handleNewView() NEWVIEW from [%d]\n", msg.SrcID)  
  
    peerSelf.Mutex.Lock()  
    log_message(VERBOSE_DEBUG, "handleNewView() Change ViewID,MemebershipList\n")  
  
    peerSelf.ViewID = msg.ViewID  
    peerSelf.MemberList = msg.MemberList  
  
    peerSelf.PendingOperations = []Message{}  
    peerSelf.Mutex.Unlock()  
  
    // Print  
    printMembership(peerSelf, peerList)  
    log_message(VERBOSE_DEBUG, "handleNewView() Done!\n")  
  
    //Heartbeat  
    if !peerSelf.HeartbeatStarted {  
       peerSelf.HeartbeatStarted = true  
       go startHeartbeatProcesses(peerSelf, peerList)  
    }  
}  
  
// Universal  
func sendMessageToPeer(msg Message, peerID int, peerList *PeerList) error {  
    log_message(VERBOSE_DEBUG, "sendMessageToPeer() send [%+v]\n", msg)  
    //1. Find whom to connect  
    var targetPeer *Peer  
    targetPeer, _ = GetPeerByID(peerList, peerID)  
    if targetPeer == nil {  
       return fmt.Errorf("sendMessageToPeer() target peer [%d] not found", peerID)  
    }  
  
    //2.Connect  
    address := fmt.Sprintf("%s:%d", targetPeer.IP, targetPeer.TCPCommunicationPort) // Make [IP]:[PORT]  
    conn, err := net.Dial("tcp", address)                                           // Conenct  
  
    if err != nil {  
       return fmt.Errorf("sendMessageToPeer() failed to connect to [%d][%s: %v", peerID, targetPeer.IP, err)  
    }  
    defer conn.Close()  
  
    //3.Serialization  
    encoder := json.NewEncoder(conn)  
    if err := encoder.Encode(msg); err != nil {  
       return fmt.Errorf("sendMessageToPeer() failed to send message to peer %d: %v", peerID, err)  
    }  
  
    return nil  
}  
  
func printMembership(selfPeer *Peer, peerList *PeerList) {  
    selfPeer.Mutex.Lock()  
    defer selfPeer.Mutex.Unlock()  
    leaderP, _ := GetPeerLeader(peerList)  
    log_message(VERBOSE_SUBMISSION, "{peer_id:%d, view_id: %d, leader: %d, memb_list: [%s]}\n",  
       selfPeer.PeerID, selfPeer.ViewID, leaderP.PeerID, intSliceToString(selfPeer.MemberList))  
} // Print peer's membership  
func intSliceToString(ints []int) string {  
    var result []string  
    for _, num := range ints {  
       result = append(result, fmt.Sprintf("%d", num))  
    }  
    return strings.Join(result, ",")  
} // Int List to String (Comma Seperated)  
  
func clientLeader(selfPeer *Peer, peerList *PeerList) {  
    log_message(VERBOSE_INFO, "main() I am the leader! NOT JOIN and just PRINT\n")  
  
    selfPeer.Mutex.Lock()  
    selfPeer.ViewID = 1  
    selfPeer.LeaderID = selfPeer.PeerID  
    selfPeer.MemberList = []int{selfPeer.PeerID} // Add myself in the member list  
    selfPeer.Mutex.Unlock()  
  
    printMembership(selfPeer, peerList)  
  
    //Heartbeat Start  
    if !selfPeer.HeartbeatStarted {  
       selfPeer.HeartbeatStarted = true  
       go startHeartbeatProcesses(selfPeer, peerList)  
    }  
}  
func clientNonLeader(selfPeer *Peer, joinDelay time.Duration, peerList *PeerList, crashDelay time.Duration) {  
    /*  
       It's not a leader    */    leaderP, err := GetPeerLeader(peerList)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "clientNonLeader() Failed to get leader: %v\n", err)  
       return  
    }  
  
    log_message(VERBOSE_INFO, "clientNonLeader() I am not the leader! JOIN to %d\n", leaderP.PeerID)  
  
    joinMsg := Message{  
       MessageType: JOIN,  
       SrcID:       selfPeer.PeerID,  
       DestID:      leaderP.PeerID,  
       LeaderID:    leaderP.PeerID,  
    }  
  
    maxRetries := 10  
    retryInterval := 2 * time.Second // Wait for the first time  
  
    time.Sleep(joinDelay)  
    for attempt := 1; attempt <= maxRetries; attempt++ {  
  
       if attempt > 1 {  
          log_message(VERBOSE_INFO, "clientNonLeader() ATTEMPT : [%d]\n", attempt)  
       }  
  
       leaderPeer, err := GetPeerLeader(peerList) // Get the leader peer  
       if err != nil {  
          log_message(VERBOSE_ERROR, "clientNonLeader() Failed to get leader: %v\n", err)  
          return  
       }  
  
       err = sendMessageToPeer(joinMsg, leaderPeer.PeerID, peerList) // Use the leader's SrcID  
       if err == nil {  
          log_message(VERBOSE_INFO, "clientNonLeader() Successfully sent JOIN message to leader.\n")  
          break  
       }  
  
       log_message(VERBOSE_ERROR, "clientNonLeader() Attempt %d: Failed to send JOIN message: %v\n", attempt, err)  
       if attempt < maxRetries {  
          time.Sleep(retryInterval)  
       } else {  
          log_message(VERBOSE_ERROR, "clientNonLeader() Exceeded maximum retry attempts. Exiting.\n")  
          os.Exit(1)  
       }  
    }  
  
    //CRASH HANDLING  
    if crashDelay > 0 {  
  
       time.Sleep(crashDelay)  
       log_message(VERBOSE_SUBMISSION, "{peer_id:%d, view_id: %d, leader: %d, message:\"crashing\"}\n",  
          selfPeer.PeerID, selfPeer.ViewID, leaderP.LeaderID)  
       os.Exit(0)  
    }  
}  
  
/*  
UDP Heartbeat Server/Client  
*/  
func startHeartbeatProcesses(selfPeer *Peer, peerList *PeerList) {  
    /*  
          Individual Go-Routine for each process  
       UDPServer->HandleHeartbeat    */    log_message(VERBOSE_DEBUG, "startHeartbeatProcesses NOW.\n")  
    go startUDPHeartbeatServer(selfPeer, peerList)  
    go sendHeartbeats(selfPeer, peerList)  
    go monitorHeartbeats(selfPeer, peerList)  
}  
  
/*  
UDP SERVER  
*/  
func startUDPHeartbeatServer(selfPeer *Peer, peerList *PeerList) {  
    //Address Struct Creation  
    addr := net.UDPAddr{  
       Port: selfPeer.UDPHeartbeatPort,  
       IP:   net.ParseIP(selfPeer.IP),  
    }  
    //Open a UDP Server  
    conn, err := net.ListenUDP("udp", &addr)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "Error starting UDP server: %v\n", err)  
       return  
    }  
    defer conn.Close() // Auto-clear  
    log_message(VERBOSE_INFO, "startUDPHeartbeatServer() UDP server started %s:%d\n", addr.IP, addr.Port)  
    buffer := make([]byte, 1024)  
    for {  
       n, _, err := conn.ReadFromUDP(buffer)  
       if err != nil {  
          log_message(VERBOSE_ERROR, "Error reading UDP message: %v\n", err)  
          continue  
       }  
       var hbMsg HeartbeatMessage  
       /*  
          https://pkg.go.dev/encoding/       */       err = json.Unmarshal(buffer[:n], &hbMsg)  
       if err != nil {  
          log_message(VERBOSE_ERROR, "Error unmarshalling heartbeat: %v\n", err)  
          continue  
       }  
       handleHeartbeat(hbMsg, selfPeer)  
    }  
}  
func handleHeartbeat(hbMsg HeartbeatMessage, selfPeer *Peer) {  
    heartbeatMutex.Lock()  
    defer heartbeatMutex.Unlock()  
  
    // ViewID has to be same as the current ViewID  
    // OldViewID? Ignore it.    if hbMsg.ViewID != selfPeer.ViewID {  
       log_message(VERBOSE_DEBUG, "handleHeartbeat() Ignoring heartbeat from %d with old ViewID %d\n", hbMsg.SrcID, hbMsg.ViewID)  
       return  
    }  
    //log_message(VERBOSE_INFO, "handleHeartbeat() Receiving HBMSG  %d->%d [V#:%d]\n", hbMsg.SrcID, hbMsg.DestID, hbMsg.ViewID)  
    heartbeatTimestamps[hbMsg.SrcID] = time.Now()  
    //log_message(VERBOSE_DEBUG, "handleHeartbeat() [%+v]\n", heartbeatTimestamps)  
}  
  
/*  
Failure Detector  
*/  
func sendHeartbeats(selfPeer *Peer, peerList *PeerList) {  
    /*  
       https://mingrammer.com/gobyexample/tickers/       Each peer will broadcast a HEARTBEAT message every time a timeout T expires.    */    ticker := time.NewTicker(HEARTBEAT_INTERVAL)  
    defer ticker.Stop()  
  
    for {  
       <-ticker.C  
       /*  
          Dest = During the next function       */       hbMsg := HeartbeatMessage{  
          SrcID:  selfPeer.PeerID,  
          ViewID: selfPeer.ViewID,  
       }  
       sendHeartbeatToAll(hbMsg, peerList, selfPeer)  
    }  
}  
func sendHeartbeatToAll(hbMsg HeartbeatMessage, peerList *PeerList, selfPeer *Peer) {  
    // Lock the selfPeer mutex to safely access MemberList  
    selfPeer.Mutex.Lock()  
    currentMembers := make([]int, len(selfPeer.MemberList))  
    copy(currentMembers, selfPeer.MemberList)  
    selfPeer.Mutex.Unlock()  
  
    // For each member in the current membership list, send heartbeat  
    for _, memberID := range currentMembers {  
       if memberID == hbMsg.SrcID {  
          continue  
       }  
       peer, err := GetPeerByID(peerList, memberID)  
       if err != nil {  
          log_message(VERBOSE_WARNING, "sendHeartbeatToAll() Peer not found: %d\n", memberID)  
          continue  
       }  
       hbMsg.DestID = peer.PeerID  
       go sendHeartbeat(hbMsg, peer) // pass peer as a pointer  
    }  
}  
  
func sendHeartbeat(hbMsg HeartbeatMessage, peer *Peer) {  
    /*  
       Actually Sending a UDP Packet       Marshal (Serialize)    */    conn, err := net.DialUDP("udp", nil, &net.UDPAddr{  
       IP:   net.ParseIP(peer.IP),  
       Port: peer.UDPHeartbeatPort,  
    })  
    if err != nil {  
       log_message(VERBOSE_ERROR, "Error connecting to peer %d: %v\n", peer.PeerID, err)  
       return  
    }  
    defer conn.Close()  
  
    data, err := json.Marshal(hbMsg)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "Error marshalling heartbeat: %v\n", err)  
       return  
    }  
    //log_message(VERBOSE_INFO, "sendHeartbeat() Sending HBMSG  %d->%d [V#:%d]\n", hbMsg.SrcID, hbMsg.DestID, hbMsg.ViewID)  
    conn.Write(data)  
}  
  
func monitorHeartbeats(selfPeer *Peer, peerList *PeerList) {  
    ticker := time.NewTicker(1000 * time.Millisecond)  
    defer ticker.Stop()  
  
    for {  
       <-ticker.C  
       checkForFailures(selfPeer, peerList)  
    }  
}  
func checkForFailures(selfPeer *Peer, peerList *PeerList) {  
    heartbeatMutex.Lock()  
    defer heartbeatMutex.Unlock()  
    /*  
       Instead of counting actual failures, uses INTERVAL time 2    */    currentTime := time.Now()  
    //log_message(VERBOSE_DEBUG, "checkForFailures() [%s]\n", heartbeatTimestamps)  
    for peerID, lastHeartbeat := range heartbeatTimestamps {  
       //log_message(VERBOSE_DEBUG, "checkForFailures() CHECKING Failure ID:%d,TIME:%s\n", peerID, currentTime.Sub(lastHeartbeat))  
       if peerID == selfPeer.PeerID {  
          continue  
       }  
       if currentTime.Sub(lastHeartbeat) > 2*HEARTBEAT_INTERVAL {  
          log_message(VERBOSE_INFO, "checkForFailures() Failure DETECTED\n")  
          /*  
             1. Fail IF the failure is detected             2. Current time - last heartbeat time          */          handlePeerFailure(peerID, selfPeer, peerList)  
       }  
    }  
}  
func handlePeerFailure(failedPeerID int, selfPeer *Peer, peerList *PeerList) {  
    log_message(VERBOSE_INFO, "handlePeerFailure() Failure Action Activated\n")  
  
    delete(heartbeatTimestamps, failedPeerID)  
  
    // 리더 장애 여부 확인  
    isLeaderFailed := false  
    if selfPeer.LeaderID == failedPeerID {  
       isLeaderFailed = true  
    }  
  
    // 출력  
    if isLeaderFailed {  
       log_message(VERBOSE_SUBMISSION, "{peer_id:%d, view_id: %d, leader: %d, message:\"peer %d (leader) unreachable\"}\n",  
          selfPeer.PeerID, selfPeer.ViewID, selfPeer.LeaderID, failedPeerID)  
    } else {  
       log_message(VERBOSE_SUBMISSION, "{peer_id:%d, view_id: %d, leader: %d, message:\"peer %d unreachable\"}\n",  
          selfPeer.PeerID, selfPeer.ViewID, selfPeer.LeaderID, failedPeerID)  
    }  
  
    // 리더인 경우 삭제 프로토콜 시작  
    if selfPeer.IsLeader {  
       log_message(VERBOSE_INFO, "handlePeerFailure() I am the leader. Initiating delete protocol.\n")  
       initiateDeleteProtocol(failedPeerID, selfPeer, peerList)  
    } else {  
       // 리더가 아닌 경우, 리더가 삭제 프로토콜을 시작할 때까지 대기  
       log_message(VERBOSE_INFO, "handlePeerFailure() Waiting for leader to initiate delete protocol.\n")  
    }  
  
    // 리더 장애 시 새로운 리더 선출  
    if isLeaderFailed {  
       electNewLeader(selfPeer, peerList)  
    }  
}  
func electNewLeader(selfPeer *Peer, peerList *PeerList) {  
    selfPeer.Mutex.Lock()  
    defer selfPeer.Mutex.Unlock()  
  
    // 가장 낮은 ID를 가진 피어를 새로운 리더로 설정  
    newLeaderID := selfPeer.PeerID  
    for _, id := range selfPeer.MemberList {  
       if id < newLeaderID {  
          newLeaderID = id  
       }  
    }  
    selfPeer.LeaderID = newLeaderID  
    selfPeer.IsLeader = (selfPeer.PeerID == newLeaderID)  
  
    if selfPeer.IsLeader {  
       log_message(VERBOSE_INFO, "I am the new leader now!\n")  
       initiateReconciliation(selfPeer, peerList)  
    }  
}  
func initiateReconciliation(selfPeer *Peer, peerList *PeerList) {  
    // NEWLEADER 메시지를 보내서 펜딩된 오퍼레이션이 있는지 확인  
    newLeaderMsg := Message{  
       MessageType: NEWLEADER,  
       SrcID:       selfPeer.PeerID,  
       ViewID:      selfPeer.ViewID,  
       LeaderID:    selfPeer.PeerID,  
       Operation:   PENDING,  
    }  
  
    var wg sync.WaitGroup  
    for _, memberID := range selfPeer.MemberList {  
       if memberID == selfPeer.PeerID {  
          continue  
       }  
       newLeaderMsg.DestID = memberID  
       wg.Add(1)  
       go func(memberID int, msg Message) {  
          defer wg.Done()  
          if err := sendMessageToPeer(msg, memberID, peerList); err != nil {  
             log_message(VERBOSE_ERROR, "Failed to send NEWLEADER to [%d]: %v\n", memberID, err)  
          }  
       }(memberID, newLeaderMsg)  
    }  
    wg.Wait()  
  
    // 펜딩된 오퍼레이션 처리 (예제에서는 단순화하여 처리하지 않음)  
}  
func handleNewLeader(msg Message, peer *Peer, peerList *PeerList) {  
    peer.Mutex.Lock()  
    peer.LeaderID = msg.LeaderID  
    peer.Mutex.Unlock()  
  
    log_message(VERBOSE_INFO, "New leader is Peer %d\n", msg.LeaderID)  
  
    // 펜딩된 오퍼레이션이 있는지 확인하고 응답  
    var pendingOp Message  
    if len(peer.PendingOperations) > 0 {  
       pendingOp = peer.PendingOperations[0]  
    } else {  
       pendingOp = Message{  
          Operation: NONE,  
       }  
    }  
  
    responseMsg := Message{  
       MessageType: msg.MessageType,  
       SrcID:       peer.PeerID,  
       DestID:      msg.SrcID,  
       ViewID:      peer.ViewID,  
       LeaderID:    peer.LeaderID,  
       Operation:   pendingOp.Operation,  
       RequestID:   pendingOp.RequestID,  
       NewPeerID:   pendingOp.NewPeerID,  
    }  
  
    if err := sendMessageToPeer(responseMsg, responseMsg.DestID, peerList); err != nil {  
       log_message(VERBOSE_ERROR, "Failed to send response to new leader [%d]: %v\n", msg.LeaderID, err)  
    }  
}  
  
// Part 3  
  
func initiateDeleteProtocol(failedPeerID int, selfPeer *Peer, peerList *PeerList) {  
    selfPeer.Mutex.Lock()  
    viewID := selfPeer.ViewID  
    currentMembers := make([]int, len(selfPeer.MemberList))  
    copy(currentMembers, selfPeer.MemberList)  
    selfPeer.Mutex.Unlock()  
  
    if _, exists := viewStates[viewID]; !exists {  
       viewStates[viewID] = &ViewState{  
          Requests: make(map[int]*RequestState),  
          ViewID:   viewID,  
       }  
    }  
  
    currentProcessingID = failedPeerID  
  
    reqMsg := Message{  
       MessageType: REQ,  
       Operation:   DEL,  
       ViewID:      viewID,  
       SrcID:       selfPeer.PeerID,  
       LeaderID:    selfPeer.PeerID,  
       NewPeerID:   failedPeerID,  
    }  
  
    var wg sync.WaitGroup  
    for _, memberID := range currentMembers {  
       if memberID == selfPeer.PeerID || memberID == failedPeerID {  
          continue  
       }  
       requestID := int(time.Now().UnixNano())  
       viewStates[viewID].ADD(requestID, selfPeer.PeerID, memberID, true, false)  
  
       reqMsgCopy := reqMsg  
       reqMsgCopy.RequestID = requestID  
       reqMsgCopy.DestID = memberID  
       wg.Add(1)  
       go func(memberID int, reqMsg Message) {  
          defer wg.Done()  
          if err := sendMessageToPeer(reqMsg, memberID, peerList); err != nil {  
             log_message(VERBOSE_ERROR, "Failed to send REQ to [%d]: %v\n", memberID, err)  
          }  
       }(memberID, reqMsgCopy)  
    }  
    wg.Wait()  
}  
  
func main() {  
    go func() {  
       log.Println(http.ListenAndServe("localhost:6060", nil))  
    }()  
  
    var hostsFile string  
    var joinDelayParameter float64  
    var crashDelayParameter float64  
    var testCase4 bool  
  
    // Required  
    flag.StringVar(&hostsFile, "h", "", "REQUIRED! hostfile filename")  
    // Not required  
    flag.Float64Var(&joinDelayParameter, "d", 1, "start delay in seconds (can be a decimal)")  
    flag.Float64Var(&crashDelayParameter, "c", 0, "delay after JOIN message before crashing (in seconds)")  
    flag.BoolVar(&testCase4, "t", false, "TESTCASE 4 flag")  
  
    flag.Parse()  
    //Decimal to Time Duration  
    joinDelay := time.Duration(joinDelayParameter * float64(time.Second))  
    crashDelay := time.Duration(crashDelayParameter * float64(time.Second))  
  
    // HostFile Load  
    if hostsFile == "" {  
       log_message(VERBOSE_ERROR, "NO HOSTSFILE PROVIDED. CHECK YOUR PARAMETER.")  
       return  
    }  
    peerList, err := loadHosts(hostsFile)  
    if err != nil {  
       log_message(VERBOSE_ERROR, "(main) HOSTFILE READER FAILED!: %v\n", err)  
       return  
    }  
    printHosts(peerList)  
  
    // Self Detection  
    var selfPeer *Peer  
    selfPeer, _ = GetPeerSelf(peerList)  
    if selfPeer == nil {  
       log_message(VERBOSE_ERROR, "(main) I can't find myself")  
       return  
    }  
  
    go startTCPServer(selfPeer, peerList) // Server Running  
  
    // JOIN MESSAGE    // Am I a leader?    if selfPeer.IsLeader {  
       clientLeader(selfPeer, peerList)  
    } else {  
       clientNonLeader(selfPeer, joinDelay, peerList, crashDelay)  
    }  
  
    select {}  
}

이건 나의 코드고 
four   | [Config] Total [5] Hosts loaded.
four   | SrcID  IP           TCP Port UDP Port Hostname        IsLeader   IsSelf     ViewID LeaderID MemberList         PendingOperation  
four   | 1      192.168.144.5 3000     5000     one             true       false      0      0      [] []
four   | 2      192.168.144.2 3000     5000     two             false      false      0      0      [] []
four   | 3      192.168.144.6 3000     5000     three           false      false      0      0      [] []
four   | 4      192.168.144.3 3000     5000     four            false      true       0      0      [] []
four   | 5      192.168.144.4 3000     5000     five            false      false      0      0      [] []
four   | clientNonLeader() I am not the leader! JOIN to 1
four   | startTCPServer() TCP server started 192.168.144.3:3000
five   | 1. [CONFIG] READING A HOSTFILE
five   | [Config] Total [5] Hosts loaded.
five   | SrcID  IP           TCP Port UDP Port Hostname        IsLeader   IsSelf     ViewID LeaderID MemberList         PendingOperation  
five   | 1      192.168.144.5 3000     5000     one             true       false      0      0      [] []
five   | 2      192.168.144.2 3000     5000     two             false      false      0      0      [] []
five   | 3      192.168.144.6 3000     5000     three           false      false      0      0      [] []
five   | 4      192.168.144.3 3000     5000     four            false      false      0      0      [] []
five   | 5      192.168.144.4 3000     5000     five            false      true       0      0      [] []
five   | clientNonLeader() I am not the leader! JOIN to 1
five   | startTCPServer() TCP server started 192.168.144.4:3000
three  | 1. [CONFIG] READING A HOSTFILE
one    | 1. [CONFIG] READING A HOSTFILE
one    | [Config] Total [5] Hosts loaded.
one    | SrcID  IP           TCP Port UDP Port Hostname        IsLeader   IsSelf     ViewID LeaderID MemberList         PendingOperation  
one    | 1      192.168.144.5 3000     5000     one             true       true       0      0      [1                 ] []
one    | 2      192.168.144.2 3000     5000     two             false      false      0      0      [] []
one    | 3      192.168.144.6 3000     5000     three           false      false      0      0      [] []
one    | 4      192.168.144.3 3000     5000     four            false      false      0      0      [] []
one    | 5      192.168.144.4 3000     5000     five            false      false      0      0      [] []
one    | main() I am the leader! NOT JOIN and just PRINT
one    | {peer_id:1, view_id: 1, leader: 1, memb_list: [1]}
one    | startHeartbeatProcesses NOW.
one    | startTCPServer() TCP server started 192.168.144.5:3000
one    | startUDPHeartbeatServer() UDP server started 192.168.144.5:5000
three  | [Config] Total [5] Hosts loaded.
three  | SrcID  IP           TCP Port UDP Port Hostname        IsLeader   IsSelf     ViewID LeaderID MemberList         PendingOperation  
three  | 1      192.168.144.5 3000     5000     one             true       false      0      0      [] []
three  | 2      192.168.144.2 3000     5000     two             false      false      0      0      [] []
three  | 3      192.168.144.6 3000     5000     three           false      true       0      0      [] []
three  | 4      192.168.144.3 3000     5000     four            false      false      0      0      [] []
three  | 5      192.168.144.4 3000     5000     five            false      false      0      0      [] []
three  | clientNonLeader() I am not the leader! JOIN to 1
three  | startTCPServer() TCP server started 192.168.144.6:3000
two    | [Config] Total [5] Hosts loaded.
two    | SrcID  IP           TCP Port UDP Port Hostname        IsLeader   IsSelf     ViewID LeaderID MemberList         PendingOperation  
two    | 1      192.168.144.5 3000     5000     one             true       false      0      0      [] []
two    | 2      192.168.144.2 3000     5000     two             false      true       0      0      [] []
two    | 3      192.168.144.6 3000     5000     three           false      false      0      0      [] []
two    | 4      192.168.144.3 3000     5000     four            false      false      0      0      [] []
two    | 5      192.168.144.4 3000     5000     five            false      false      0      0      [] []
two    | clientNonLeader() I am not the leader! JOIN to 1
two    | startTCPServer() TCP server started 192.168.144.2:3000
one    | Received message: {MessageType:0 Operation:0 SrcID:2 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}
one    | handleJoin() RECEIVED JOIN FROM [2]
two    | sendMessageToPeer() send [{MessageType:0 Operation:0 SrcID:2 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}]
two    | clientNonLeader() Successfully sent JOIN message to leader.
one    | handleJoin() First JOIN message, SKIPPING REQ message.
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:2 LeaderID:1 NewPeerID:0 MemberList:[1 2]}]
one    | sendNewView() Sent NEWVIEW to specified members
one    | {peer_id:1, view_id: 2, leader: 1, memb_list: [1,2]}
two    | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:2 LeaderID:1 NewPeerID:0 MemberList:[1 2]}
two    | handleNewView() NEWVIEW from [1]
two    | handleNewView() Change ViewID,MemebershipList
two    | {peer_id:2, view_id: 2, leader: 1, memb_list: [1,2]}
two    | handleNewView() Done!
two    | startHeartbeatProcesses NOW.
two    | startUDPHeartbeatServer() UDP server started 192.168.144.2:5000
one    | Received message: {MessageType:0 Operation:0 SrcID:3 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}
one    | handleJoin() RECEIVED JOIN FROM [3]
three  | sendMessageToPeer() send [{MessageType:0 Operation:0 SrcID:3 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}]
two    | Received message: {MessageType:1 Operation:1 SrcID:1 DestID:2 RequestID:1729223585299357459 ViewID:2 LeaderID:1 NewPeerID:3 MemberList:[]}
two    | handleReq() REQ from [1]
two    | handleReq() ADD operation pending
two    | handleReq() REQ - OK MSG creating
two    | handleReq() REQ - OK MSG sending
two    | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223585299357459 ViewID:2 LeaderID:0 NewPeerID:0 MemberList:[]}]
two    | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:3 LeaderID:1 NewPeerID:0 MemberList:[1 2 3]}
two    | handleNewView() NEWVIEW from [1]
two    | handleNewView() Change ViewID,MemebershipList
one    | sendReqToMembers() STARTING
three  | clientNonLeader() Successfully sent JOIN message to leader.
two    | {peer_id:2, view_id: 3, leader: 1, memb_list: [1,2,3]}
two    | handleNewView() Done!
one    | CURRENT TURN TO SEND REQ : [1]
one    | SELF DETECTED. SKIPPING.
one    | CURRENT TURN TO SEND REQ : [2]
one    | sendReqToMembers() SENDING REQ [{1 1 1 2 1729223585299357459 2 1 3 []}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:1 SrcID:1 DestID:2 RequestID:1729223585299357459 ViewID:2 LeaderID:1 NewPeerID:3 MemberList:[]}]
one    | Received message: {MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223585299357459 ViewID:2 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 2. REQ ID: 1729223585299357459, VIEW ID: 2
one    | Viewstates RequestID[1729223585299357459] Update now.
one    | handleOk() All OK messages received for ViewID: 2. Sending NEWVIEW.
three  | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:3 LeaderID:1 NewPeerID:0 MemberList:[1 2 3]}
three  | handleNewView() NEWVIEW from [1]
three  | handleNewView() Change ViewID,MemebershipList
three  | {peer_id:3, view_id: 3, leader: 1, memb_list: [1,2,3]}
three  | handleNewView() Done!
three  | startHeartbeatProcesses NOW.
three  | startUDPHeartbeatServer() UDP server started 192.168.144.6:5000
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:3 LeaderID:1 NewPeerID:0 MemberList:[1 2 3]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:3 LeaderID:1 NewPeerID:0 MemberList:[1 2 3]}]
one    | sendNewView() Sent NEWVIEW to specified members
one    | {peer_id:1, view_id: 3, leader: 1, memb_list: [1,2,3]}
four   | sendMessageToPeer() send [{MessageType:0 Operation:0 SrcID:4 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}]
four   | clientNonLeader() Successfully sent JOIN message to leader.
one    | Received message: {MessageType:0 Operation:0 SrcID:4 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}
one    | handleJoin() RECEIVED JOIN FROM [4]
one    | sendReqToMembers() STARTING
one    | CURRENT TURN TO SEND REQ : [1]
one    | SELF DETECTED. SKIPPING.
one    | CURRENT TURN TO SEND REQ : [2]
one    | CURRENT TURN TO SEND REQ : [3]
one    | sendReqToMembers() SENDING REQ [{1 1 1 3 1729223587108268418 3 1 4 []}]
one    | sendReqToMembers() SENDING REQ [{1 1 1 2 1729223587108250668 3 1 4 []}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:1 SrcID:1 DestID:3 RequestID:1729223587108268418 ViewID:3 LeaderID:1 NewPeerID:4 MemberList:[]}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:1 SrcID:1 DestID:2 RequestID:1729223587108250668 ViewID:3 LeaderID:1 NewPeerID:4 MemberList:[]}]
two    | Received message: {MessageType:1 Operation:1 SrcID:1 DestID:2 RequestID:1729223587108250668 ViewID:3 LeaderID:1 NewPeerID:4 MemberList:[]}
three  | Received message: {MessageType:1 Operation:1 SrcID:1 DestID:3 RequestID:1729223587108268418 ViewID:3 LeaderID:1 NewPeerID:4 MemberList:[]}
three  | handleReq() REQ from [1]
three  | handleReq() ADD operation pending
three  | handleReq() REQ - OK MSG creating
three  | handleReq() REQ - OK MSG sending
three  | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:3 DestID:1 RequestID:1729223587108268418 ViewID:3 LeaderID:0 NewPeerID:0 MemberList:[]}]
two    | handleReq() REQ from [1]
two    | handleReq() ADD operation pending
two    | handleReq() REQ - OK MSG creating
two    | handleReq() REQ - OK MSG sending
two    | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223587108250668 ViewID:3 LeaderID:0 NewPeerID:0 MemberList:[]}]
two    | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:4 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4]}
two    | handleNewView() NEWVIEW from [1]
two    | handleNewView() Change ViewID,MemebershipList
two    | {peer_id:2, view_id: 4, leader: 1, memb_list: [1,2,3,4]}
two    | handleNewView() Done!
one    | Received message: {MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223587108250668 ViewID:3 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 2. REQ ID: 1729223587108250668, VIEW ID: 3
one    | Viewstates RequestID[1729223587108250668] Update now.
one    | handleOk() Waiting for more OK messages for ViewID: 3
one    | Received message: {MessageType:2 Operation:0 SrcID:3 DestID:1 RequestID:1729223587108268418 ViewID:3 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 3. REQ ID: 1729223587108268418, VIEW ID: 3
one    | Viewstates RequestID[1729223587108268418] Update now.
one    | handleOk() All OK messages received for ViewID: 3. Sending NEWVIEW.
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:4 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4]}]
four   | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:4 RequestID:0 ViewID:4 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4]}
three  | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:4 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4]}
four   | handleNewView() NEWVIEW from [1]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:4 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:4 RequestID:0 ViewID:4 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4]}]
one    | sendNewView() Sent NEWVIEW to specified members
one    | {peer_id:1, view_id: 4, leader: 1, memb_list: [1,2,3,4]}
three  | handleNewView() NEWVIEW from [1]
three  | handleNewView() Change ViewID,MemebershipList
three  | {peer_id:3, view_id: 4, leader: 1, memb_list: [1,2,3,4]}
three  | handleNewView() Done!
four   | handleNewView() Change ViewID,MemebershipList
four   | {peer_id:4, view_id: 4, leader: 1, memb_list: [1,2,3,4]}
four   | handleNewView() Done!
four   | startHeartbeatProcesses NOW.
four   | startUDPHeartbeatServer() UDP server started 192.168.144.3:5000
two    | Received message: {MessageType:1 Operation:1 SrcID:1 DestID:2 RequestID:1729223589261280585 ViewID:4 LeaderID:1 NewPeerID:5 MemberList:[]}
two    | handleReq() REQ from [1]
two    | handleReq() ADD operation pending
two    | handleReq() REQ - OK MSG creating
two    | handleReq() REQ - OK MSG sending
two    | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223589261280585 ViewID:4 LeaderID:0 NewPeerID:0 MemberList:[]}]
two    | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}
two    | handleNewView() NEWVIEW from [1]
two    | handleNewView() Change ViewID,MemebershipList
two    | {peer_id:2, view_id: 5, leader: 1, memb_list: [1,2,3,4,5]}
two    | handleNewView() Done!
five   | sendMessageToPeer() send [{MessageType:0 Operation:0 SrcID:5 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}]
five   | clientNonLeader() Successfully sent JOIN message to leader.
one    | Received message: {MessageType:0 Operation:0 SrcID:5 DestID:1 RequestID:0 ViewID:0 LeaderID:1 NewPeerID:0 MemberList:[]}
three  | Received message: {MessageType:1 Operation:1 SrcID:1 DestID:3 RequestID:1729223589261315669 ViewID:4 LeaderID:1 NewPeerID:5 MemberList:[]}
four   | Received message: {MessageType:1 Operation:1 SrcID:1 DestID:4 RequestID:1729223589261330044 ViewID:4 LeaderID:1 NewPeerID:5 MemberList:[]}
four   | handleReq() REQ from [1]
four   | handleReq() ADD operation pending
four   | handleReq() REQ - OK MSG creating
four   | handleReq() REQ - OK MSG sending
four   | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:4 DestID:1 RequestID:1729223589261330044 ViewID:4 LeaderID:0 NewPeerID:0 MemberList:[]}]
four   | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:4 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}
one    | handleJoin() RECEIVED JOIN FROM [5]
five   | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:5 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}
three  | handleReq() REQ from [1]
four   | handleNewView() NEWVIEW from [1]
four   | handleNewView() Change ViewID,MemebershipList
four   | {peer_id:4, view_id: 5, leader: 1, memb_list: [1,2,3,4,5]}
four   | handleNewView() Done!
one    | sendReqToMembers() STARTING
one    | CURRENT TURN TO SEND REQ : [1]
one    | SELF DETECTED. SKIPPING.
one    | CURRENT TURN TO SEND REQ : [2]
one    | CURRENT TURN TO SEND REQ : [3]
one    | CURRENT TURN TO SEND REQ : [4]
one    | sendReqToMembers() SENDING REQ [{1 1 1 4 1729223589261330044 4 1 5 []}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:1 SrcID:1 DestID:4 RequestID:1729223589261330044 ViewID:4 LeaderID:1 NewPeerID:5 MemberList:[]}]
five   | handleNewView() NEWVIEW from [1]
three  | handleReq() ADD operation pending
one    | sendReqToMembers() SENDING REQ [{1 1 1 2 1729223589261280585 4 1 5 []}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:1 SrcID:1 DestID:2 RequestID:1729223589261280585 ViewID:4 LeaderID:1 NewPeerID:5 MemberList:[]}]
one    | sendReqToMembers() SENDING REQ [{1 1 1 3 1729223589261315669 4 1 5 []}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:1 SrcID:1 DestID:3 RequestID:1729223589261315669 ViewID:4 LeaderID:1 NewPeerID:5 MemberList:[]}]
one    | Received message: {MessageType:2 Operation:0 SrcID:4 DestID:1 RequestID:1729223589261330044 ViewID:4 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 4. REQ ID: 1729223589261330044, VIEW ID: 4
one    | Viewstates RequestID[1729223589261330044] Update now.
one    | handleOk() Waiting for more OK messages for ViewID: 4
one    | Received message: {MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223589261280585 ViewID:4 LeaderID:0 NewPeerID:0 MemberList:[]}
five   | handleNewView() Change ViewID,MemebershipList
three  | handleReq() REQ - OK MSG creating
three  | handleReq() REQ - OK MSG sending
three  | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:3 DestID:1 RequestID:1729223589261315669 ViewID:4 LeaderID:0 NewPeerID:0 MemberList:[]}]
three  | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}
three  | handleNewView() NEWVIEW from [1]
three  | handleNewView() Change ViewID,MemebershipList
three  | {peer_id:3, view_id: 5, leader: 1, memb_list: [1,2,3,4,5]}
three  | handleNewView() Done!
one    | handleOk() Received OK from 2. REQ ID: 1729223589261280585, VIEW ID: 4
one    | Viewstates RequestID[1729223589261280585] Update now.
five   | {peer_id:5, view_id: 5, leader: 1, memb_list: [1,2,3,4,5]}
five   | handleNewView() Done!
five   | startHeartbeatProcesses NOW.
five   | startUDPHeartbeatServer() UDP server started 192.168.144.4:5000
one    | handleOk() Waiting for more OK messages for ViewID: 4
one    | Received message: {MessageType:2 Operation:0 SrcID:3 DestID:1 RequestID:1729223589261315669 ViewID:4 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 3. REQ ID: 1729223589261315669, VIEW ID: 4
one    | Viewstates RequestID[1729223589261315669] Update now.
one    | handleOk() All OK messages received for ViewID: 4. Sending NEWVIEW.
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:4 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:5 RequestID:0 ViewID:5 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5]}]
one    | sendNewView() Sent NEWVIEW to specified members
one    | {peer_id:1, view_id: 5, leader: 1, memb_list: [1,2,3,4,5]}
five   | {peer_id:5, view_id: 5, leader: 0, message:"crashing"}
five exited with code 0
two    | Received message: {MessageType:1 Operation:2 SrcID:1 DestID:2 RequestID:1729223595294742672 ViewID:5 LeaderID:1 NewPeerID:5 MemberList:[]}
four   | Received message: {MessageType:1 Operation:2 SrcID:1 DestID:4 RequestID:1729223595294827713 ViewID:5 LeaderID:1 NewPeerID:5 MemberList:[]}
two    | handleReq() REQ from [1]
one    | checkForFailures() Failure DETECTED
one    | handlePeerFailure() Failure Action Activated
one    | {peer_id:1, view_id: 5, leader: 1, message:"peer 5 unreachable"}
one    | handlePeerFailure() I am the leader. Initiating delete protocol.
one    | sendMessageToPeer() send [{MessageType:1 Operation:2 SrcID:1 DestID:4 RequestID:1729223595294827713 ViewID:5 LeaderID:1 NewPeerID:5 MemberList:[]}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:2 SrcID:1 DestID:2 RequestID:1729223595294742672 ViewID:5 LeaderID:1 NewPeerID:5 MemberList:[]}]
one    | sendMessageToPeer() send [{MessageType:1 Operation:2 SrcID:1 DestID:3 RequestID:1729223595294825463 ViewID:5 LeaderID:1 NewPeerID:5 MemberList:[]}]
four   | handleReq() REQ from [1]
two    | handleReq() DEL operation pending
one    | Received message: {MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223595294742672 ViewID:5 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 2. REQ ID: 1729223595294742672, VIEW ID: 5
one    | Viewstates RequestID[1729223595294742672] Update now.
one    | handleOk() Waiting for more OK messages for ViewID: 5
one    | Received message: {MessageType:2 Operation:0 SrcID:4 DestID:1 RequestID:1729223595294827713 ViewID:5 LeaderID:0 NewPeerID:0 MemberList:[]}
one    | handleOk() Received OK from 4. REQ ID: 1729223595294827713, VIEW ID: 5
one    | Viewstates RequestID[1729223595294827713] Update now.
one    | handleOk() Waiting for more OK messages for ViewID: 5
one    | Received message: {MessageType:2 Operation:0 SrcID:3 DestID:1 RequestID:1729223595294825463 ViewID:5 LeaderID:0 NewPeerID:0 MemberList:[]}
three  | Received message: {MessageType:1 Operation:2 SrcID:1 DestID:3 RequestID:1729223595294825463 ViewID:5 LeaderID:1 NewPeerID:5 MemberList:[]}
four   | handleReq() DEL operation pending
two    | handleReq() REQ - OK MSG creating
one    | handleOk() Received OK from 3. REQ ID: 1729223595294825463, VIEW ID: 5
one    | Viewstates RequestID[1729223595294825463] Update now.
one    | handleOk() All OK messages received for ViewID: 5. Sending NEWVIEW.
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:4 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}]
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:5 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}]
four   | handleReq() REQ - OK MSG creating
three  | handleReq() REQ from [1]
two    | handleReq() REQ - OK MSG sending
two    | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:2 DestID:1 RequestID:1729223595294742672 ViewID:5 LeaderID:0 NewPeerID:0 MemberList:[]}]
two    | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:2 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}
two    | handleNewView() NEWVIEW from [1]
two    | handleNewView() Change ViewID,MemebershipList
two    | {peer_id:2, view_id: 6, leader: 1, memb_list: [1,2,3,4,5,5]}
two    | handleNewView() Done!
two    | handleHeartbeat() Ignoring heartbeat from 3 with old ViewID 5
four   | handleReq() REQ - OK MSG sending
one    | handleHeartbeat() Ignoring heartbeat from 3 with old ViewID 5
three  | handleReq() DEL operation pending
three  | handleReq() REQ - OK MSG creating
three  | handleReq() REQ - OK MSG sending
three  | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:3 DestID:1 RequestID:1729223595294825463 ViewID:5 LeaderID:0 NewPeerID:0 MemberList:[]}]
three  | checkForFailures() Failure DETECTED
three  | handlePeerFailure() Failure Action Activated
three  | {peer_id:3, view_id: 5, leader: 0, message:"peer 5 unreachable"}
three  | handlePeerFailure() Waiting for leader to initiate delete protocol.
three  | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:3 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}
three  | handleNewView() NEWVIEW from [1]
three  | handleNewView() Change ViewID,MemebershipList
four   | sendMessageToPeer() send [{MessageType:2 Operation:0 SrcID:4 DestID:1 RequestID:1729223595294827713 ViewID:5 LeaderID:0 NewPeerID:0 MemberList:[]}]
three  | {peer_id:3, view_id: 6, leader: 1, memb_list: [1,2,3,4,5,5]}
three  | handleNewView() Done!
four   | Received message: {MessageType:3 Operation:0 SrcID:1 DestID:4 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}
four   | handleNewView() NEWVIEW from [1]
four   | handleNewView() Change ViewID,MemebershipList
four   | {peer_id:4, view_id: 6, leader: 1, memb_list: [1,2,3,4,5,5]}
four   | handleNewView() Done!
four   | handleHeartbeat() Ignoring heartbeat from 3 with old ViewID 5
two    | checkForFailures() Failure DETECTED
two    | handlePeerFailure() Failure Action Activated
two    | {peer_id:2, view_id: 6, leader: 0, message:"peer 5 unreachable"}
two    | handlePeerFailure() Waiting for leader to initiate delete protocol.
four   | checkForFailures() Failure DETECTED
four   | handlePeerFailure() Failure Action Activated
four   | {peer_id:4, view_id: 6, leader: 0, message:"peer 5 unreachable"}
four   | handlePeerFailure() Waiting for leader to initiate delete protocol.
one    | Failed to send NEWVIEW to [5]: sendMessageToPeer() failed to connect to [5][192.168.144.4: dial tcp 192.168.144.4:3000: connect: no route to host
one    | sendMessageToPeer() send [{MessageType:3 Operation:0 SrcID:1 DestID:5 RequestID:0 ViewID:6 LeaderID:1 NewPeerID:0 MemberList:[1 2 3 4 5 5]}]
one    | Failed to send NEWVIEW to [5]: sendMessageToPeer() failed to connect to [5][192.168.144.4: dial tcp 192.168.144.4:3000: connect: no route to host
one    | sendNewView() Sent NEWVIEW to specified members
one    | {peer_id:1, view_id: 6, leader: 1, memb_list: [1,2,3,4,5,5]}
여기는 나의 로그야.

마지막 줄에 보면 알겠지만 DELETE 프로토콜이 제대로 작동하고 있지 않아. 그리고 func handleTCPConnection(conn net.Conn, peer *Peer, peerList *PeerList) 이 부분에서도 오류가 있는거 같애. 원래 목표는 JOIN-REQ-OK-NEWVIEW 사이에 다른 피어가 JOIN 요청을 하면 거부 하는거 였는데 지금처럼 Peer가 fail해서 DEL-REQ-OK-NEWVIEW 하는 상황도 고려해서 코드를 수정해줘.